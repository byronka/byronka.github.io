<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AbstractDb.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">minum</a> &gt; <a href="index.source.html" class="el_package">com.renomad.minum.database</a> &gt; <span class="el_source">AbstractDb.java</span></div><h1>AbstractDb.java</h1><pre class="source lang-java linenums">package com.renomad.minum.database;

import com.renomad.minum.logging.ILogger;
import com.renomad.minum.state.Context;
import com.renomad.minum.utils.FileUtils;

import java.io.IOException;
import java.nio.file.Path;
import java.util.*;
import java.util.concurrent.Callable;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Function;

/**
 * The abstract database class is a representation of the essential capabilities of
 * a Minum database.
 * &lt;p&gt;
 *     There are two kinds of database provided, which only differ in how they
 *     store data on disk.  The &quot;classic&quot; kind, {@link Db}, stores each piece of
 *     data in its own file.  This is the simplest approach.
 * &lt;/p&gt;
 * &lt;p&gt;
 *     However, for significant speed gains, the new {@link DbEngine2} will
 *     store each change as an append to a file, and will consolidate the on-disk
 *     data occasionally, and on start.  That way is thousands of times faster
 *     to write to disk and to read from disk at startup.
 * &lt;/p&gt;
 * @param &lt;T&gt; This is the type of data, which is always an implementation of
 *           the {@link DbData} class.  See the code of {@link com.renomad.minum.security.Inmate}
 *           for an example of how this should look.
 */
public abstract class AbstractDb&lt;T extends DbData&lt;?&gt;&gt; {

    /**
     * The directory of the database on disk
     */
    protected final Path dbDirectory;

    /**
     * An empty instance of the type of data stored by this
     * database, used for better handling of generics.
     */
    protected final T emptyInstance;

    /**
     * Used for handling some file utilities in the database like creating directories
     */
    protected final FileUtils fileUtils;

    /**
     * Holds some system-wide information that is beneficial for components of the database
     */
    protected final Context context;

    /**
     * Used for providing logging throughout the database
     */
    protected final ILogger logger;

    /**
     * The internal data structure of the database that resides in memory.  The beating heart
     * of the database while it runs.
     */
    protected final Map&lt;Long, T&gt; data;

    /**
     * The current index, used when creating new data items.  Each item has its own
     * index value, this is where it is tracked.
     */
    protected AtomicLong index;

    // components for registered indexes (for faster read performance)

    /**
     * This data structure is a nested map used for providing indexed data search.
     * &lt;br&gt;
     * The outer map is between the name of the index and the inner map.
     * &lt;br&gt;
     * The inner map is between strings and sets of items related to that string.
     */
    protected final Map&lt;String, Map&lt;String, Set&lt;T&gt;&gt;&gt; registeredIndexes;

    /**
     * This map holds the functions that are registered to indexes, which are used
     * to construct the mappings between string values and items in the database.
     */
    protected final Map&lt;String, Function&lt;T, String&gt;&gt; partitioningMap;

<span class="fc" id="L90">    protected AbstractDb(Path dbDirectory, Context context, T instance) {</span>
<span class="fc" id="L91">        this.dbDirectory = dbDirectory;</span>
<span class="fc" id="L92">        this.context = context;</span>
<span class="fc" id="L93">        this.emptyInstance = instance;</span>
<span class="fc" id="L94">        this.data = new ConcurrentHashMap&lt;&gt;();</span>
<span class="fc" id="L95">        this.logger = context.getLogger();</span>
<span class="fc" id="L96">        this.registeredIndexes = new HashMap&lt;&gt;();</span>
<span class="fc" id="L97">        this.partitioningMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L98">        this.fileUtils = new FileUtils(logger, context.getConstants());</span>
<span class="fc" id="L99">    }</span>

    /**
     * Used to cleanly stop the database.
     * &lt;br&gt;
     * In the case of {@link Db} this will interrupt its internal queue and tell it
     * to finish up processing.
     * &lt;br&gt;
     * In the case of {@link DbEngine2} this will flush data to disk.
     */
    public abstract void stop();

    /**
     * Used to cleanly stop the database, with extra allowance of time
     * for cleanup.
     * &lt;br&gt;
     * Note that this method mostly applies to {@link Db}, and not as much
     * to {@link DbEngine2}.  Only Db uses a processing queue on a thread which
     * is what requires a longer shutdown time for interruption.
     * @param count number of loops before we are done waiting for a clean close
     *              and instead crash the instance closed.
     * @param sleepTime how long to wait, in milliseconds, for each iteration of the waiting loop.
     */
    public abstract void stop(int count, int sleepTime);


    /**
     * Write data to the database.  Use an index of 0 to store new data, and a positive
     * non-zero value to update data.
     * &lt;p&gt;&lt;em&gt;
     * Example of adding new data to the database:
     * &lt;/p&gt;&lt;/em&gt;
     * {@snippet :
     *          final var newSalt = StringUtils.generateSecureRandomString(10);
     *          final var hashedPassword = CryptoUtils.createPasswordHash(newPassword, newSalt);
     *          final var newUser = new User(0L, newUsername, hashedPassword, newSalt);
     *          userDb.write(newUser);
     * }
     * &lt;p&gt;&lt;em&gt;
     * Example of updating data:
     * &lt;/p&gt;&lt;/em&gt;
     * {@snippet :
     *         // write the updated salted password to the database
     *         final var updatedUser = new User(
     *                 user().getIndex(),
     *                 user().getUsername(),
     *                 hashedPassword,
     *                 newSalt);
     *         userDb.write(updatedUser);
     * }
     *
     * @param newData the data we are writing
     * @return the data with its new index assigned.
     */
    public abstract T write(T newData);

    /**
     * Write database data into memory
     * @param newData the new data may be totally new or an update
     * @param newElementCreated if true, this is a create.  If false, an update.
     */
    protected void writeToMemory(T newData, boolean newElementCreated) {
        // if we got here, we are safe to proceed with putting the data into memory and disk
<span class="fc" id="L162">        logger.logTrace(() -&gt; String.format(&quot;in thread %s, writing data %s&quot;, Thread.currentThread().getName(), newData));</span>
<span class="fc" id="L163">        T oldData = data.put(newData.getIndex(), newData);</span>

        // handle the indexes differently depending on whether this is a create or delete
<span class="fc bfc" id="L166" title="All 2 branches covered.">        if (newElementCreated) {</span>
<span class="fc" id="L167">            addToIndexes(newData);</span>
        } else {
<span class="fc" id="L169">            removeFromIndexes(oldData);</span>
<span class="fc" id="L170">            addToIndexes(newData);</span>
        }
<span class="fc" id="L172">    }</span>

    /**
     * When new data comes in, we look at its &quot;index&quot; value. If
     * it is zero, it's a create, and we assign it a new value.  If it is
     * positive, it is an update, and we had better find it in the database
     * already, or else throw an exception.
     * @return true if a create, false if an update
     */
    protected boolean processDataIndex(T newData) {
        // *** deal with the in-memory portion ***
<span class="fc" id="L183">        boolean newElementCreated = false;</span>
        // create a new index for the data, if needed
<span class="fc bfc" id="L185" title="All 2 branches covered.">        if (newData.getIndex() == 0) {</span>
<span class="fc" id="L186">            newData.setIndex(index.getAndIncrement());</span>
<span class="fc" id="L187">            newElementCreated = true;</span>
        } else {
            // if the data does not exist, and a positive non-zero
            // index was provided, throw an exception.
<span class="fc bfc" id="L191" title="All 2 branches covered.">            boolean dataEntryExists = data.values().stream().anyMatch(x -&gt; x.getIndex() == newData.getIndex());</span>
<span class="fc bfc" id="L192" title="All 2 branches covered.">            if (!dataEntryExists) {</span>
<span class="fc" id="L193">                throw new DbException(</span>
<span class="fc" id="L194">                        String.format(&quot;Positive indexes are only allowed when updating existing data. Index: %d&quot;,</span>
<span class="fc" id="L195">                                newData.getIndex()));</span>
            }
        }
<span class="fc" id="L198">        return newElementCreated;</span>
    }

    /**
     * Delete data
     * &lt;p&gt;&lt;em&gt;Example:&lt;/p&gt;&lt;/em&gt;
     * {@snippet :
     *      userDb.delete(user);
     * }
     *
     * @param dataToDelete the data we are serializing and writing
     */
    public abstract void delete(T dataToDelete);


    /**
     * Remove a particular item from the internal data structure in memory
     */
    protected void deleteFromMemory(T dataToDelete) {
        long dataIndex;
<span class="fc bfc" id="L218" title="All 2 branches covered.">        if (dataToDelete == null) {</span>
<span class="fc" id="L219">            throw new DbException(&quot;Invalid to be given a null value to delete&quot;);</span>
        }
<span class="fc" id="L221">        dataIndex = dataToDelete.getIndex();</span>
<span class="fc bfc" id="L222" title="All 2 branches covered.">        if (!data.containsKey(dataIndex)) {</span>
<span class="fc" id="L223">            throw new DbException(&quot;no data was found with index of &quot; + dataIndex);</span>
        }
<span class="fc" id="L225">        long finalDataIndex = dataIndex;</span>
<span class="fc" id="L226">        logger.logTrace(() -&gt; String.format(&quot;in thread %s, deleting data with index %d&quot;, Thread.currentThread().getName(), finalDataIndex));</span>
<span class="fc" id="L227">        data.remove(dataIndex);</span>
<span class="fc" id="L228">        removeFromIndexes(dataToDelete);</span>
        // if all the data was just now deleted, we need to
        // reset the index back to 1

<span class="fc bfc" id="L232" title="All 2 branches covered.">        if (data.isEmpty()) {</span>
<span class="fc" id="L233">            index.set(1);</span>
        }
<span class="fc" id="L235">    }</span>


    /**
     *  add the data to registered indexes.
     *  &lt;br&gt;
     *  For each of the registered indexes,
     *  get the stored function to obtain a string value which helps divide
     *  the overall data into partitions.
     */
    protected void addToIndexes(T dbData) {

<span class="fc bfc" id="L247" title="All 2 branches covered.">        for (var entry : partitioningMap.entrySet()) {</span>
            // a function provided by the user to obtain an index-key: a unique or semi-unique
            // value to help partition / index the data
<span class="fc" id="L250">            Function&lt;T, String&gt; indexStringFunction = entry.getValue();</span>
<span class="fc" id="L251">            String propertyAsString = indexStringFunction.apply(dbData);</span>
<span class="fc" id="L252">            Map&lt;String, Set&lt;T&gt;&gt; stringIndexMap = registeredIndexes.get(entry.getKey());</span>
<span class="fc" id="L253">            synchronized (this) {</span>
<span class="fc" id="L254">                stringIndexMap.computeIfAbsent(propertyAsString, k -&gt; new HashSet&lt;&gt;());</span>
<span class="fc" id="L255">            }</span>
            // if the index-key provides a 1-to-1 mapping to items, like UUIDs, then
            // each value will have only one item in the collection.  In other cases,
            // like when partitioning the data into multiple groups, there could easily
            // be many items per index value.
<span class="fc" id="L260">            Set&lt;T&gt; dataSet = stringIndexMap.get(propertyAsString);</span>
<span class="fc" id="L261">            dataSet.add(dbData);</span>
<span class="fc" id="L262">        }</span>
<span class="fc" id="L263">    }</span>

    /**
     * Run when an item is deleted from the database
     */
    private void removeFromIndexes(T dbData) {
<span class="fc bfc" id="L269" title="All 2 branches covered.">        for (var entry : partitioningMap.entrySet()) {</span>
            // a function provided by the user to obtain an index-key: a unique or semi-unique
            // value to help partition / index the data
<span class="fc" id="L272">            Function&lt;T, String&gt; indexStringFunction = entry.getValue();</span>
<span class="fc" id="L273">            String propertyAsString = indexStringFunction.apply(dbData);</span>
<span class="fc" id="L274">            Map&lt;String, Set&lt;T&gt;&gt; stringIndexMap = registeredIndexes.get(entry.getKey());</span>
<span class="fc" id="L275">            synchronized (this) {</span>
<span class="fc bfc" id="L276" title="All 2 branches covered.">                stringIndexMap.get(propertyAsString).removeIf(x -&gt; x.getIndex() == dbData.getIndex());</span>

                // in certain cases, we're removing one of the items that is indexed but
                // there are more left.  If there's nothing left though, we'll remove the mapping.
<span class="fc bfc" id="L280" title="All 2 branches covered.">                if (stringIndexMap.get(propertyAsString).isEmpty()) {</span>
<span class="fc" id="L281">                    stringIndexMap.remove(propertyAsString);</span>
                }
<span class="fc" id="L283">            }</span>
<span class="fc" id="L284">        }</span>
<span class="fc" id="L285">    }</span>


    /**
     * Grabs all the data from disk and returns it as a list.  This
     * method is run by various programs when the system first loads.
     */
    public abstract void loadData() throws IOException;

    /**
     * This method provides read capability for the values of a database.
     * &lt;br&gt;
     * The returned collection is a read-only view over the data, through {@link Collections#unmodifiableCollection(Collection)}
     *
     * &lt;p&gt;&lt;em&gt;Example:&lt;/em&gt;&lt;/p&gt;
     * {@snippet :
     * boolean doesUserAlreadyExist(String username) {
     *     return userDb.values().stream().anyMatch(x -&gt; x.getUsername().equals(username));
     * }
     * }
     */
    public abstract Collection&lt;T&gt; values();

    /**
     * Register an index in the database for higher performance data access.
     * &lt;p&gt;
     *     This command should be run immediately after database declaration,
     *     or more specifically, before any data is loaded from disk. Otherwise,
     *     it would be possible to skip indexing that data.
     * &lt;/p&gt;
     * &lt;br&gt;
     * Example:
     *  {@snippet :
     *           final var myDatabase = context.getDb(&quot;photos&quot;, Photograph.EMPTY);
     *           myDatabase.registerIndex(&quot;url&quot;, photo -&gt; photo.getUrl());
     *  }
     * @param indexName a string used to distinguish this index.  This string will be used again
     *                  when requesting data in a method like {@link #getIndexedData} or {@link #findExactlyOne}
     * @param keyObtainingFunction a function which obtains data from the data in this database, used
     *                             to partition the data into groups (potentially up to a 1-to-1 correspondence
     *                             between id and object)
     * @return true if the registration succeeded
     * @throws DbException if the parameters are not entered properly, if the index has already
     * been registered, or if the data has already been loaded. It is necessary that
     * this is run immediately after declaring the database. To explain further: the data is not
     * actually loaded until the first time it is needed, such as running a write or delete, or
     * if the {@link #loadData()} ()} method is run.  Creating an index map for the data that
     * is read from disk only occurs once, at data load time.  Thus, it is crucial that the
     * registerIndex command is run before any data is loaded.
     */
    public boolean registerIndex(String indexName, Function&lt;T, String&gt; keyObtainingFunction) {
<span class="fc bfc" id="L336" title="All 2 branches covered.">        if (keyObtainingFunction == null) {</span>
<span class="fc" id="L337">            throw new DbException(&quot;When registering an index, the partitioning algorithm must not be null&quot;);</span>
        }
<span class="fc bfc" id="L339" title="All 4 branches covered.">        if (indexName == null || indexName.isBlank()) {</span>
<span class="fc" id="L340">            throw new DbException(&quot;When registering an index, value must be a non-empty string&quot;);</span>
        }
<span class="fc bfc" id="L342" title="All 2 branches covered.">        if (registeredIndexes.containsKey(indexName)) {</span>
<span class="fc" id="L343">            throw new DbException(&quot;It is forbidden to register the same index more than once.  Duplicate index: \&quot;&quot;+indexName+&quot;\&quot;&quot;);</span>
        }
<span class="fc" id="L345">        HashMap&lt;String, Set&lt;T&gt;&gt; stringCollectionHashMap = new HashMap&lt;&gt;();</span>
<span class="fc" id="L346">        registeredIndexes.put(indexName, stringCollectionHashMap);</span>
<span class="fc" id="L347">        partitioningMap.put(indexName, keyObtainingFunction);</span>
<span class="fc" id="L348">        return true;</span>
    }

    /**
     * Given the name of a registered index (see {@link #registerIndex(String, Function)}),
     * use the key to find the collection of data that matches it.
     * @param indexName the name of an index
     * @param key a string value that matches a partition calculated from the partition
     *            function provided to {@link #registerIndex(String, Function)}
     * @return a collection of data, an empty collection if nothing found
     */
    public Collection&lt;T&gt; getIndexedData(String indexName, String key) {
<span class="fc bfc" id="L360" title="All 2 branches covered.">        if (!registeredIndexes.containsKey(indexName)) {</span>
<span class="fc" id="L361">            throw new DbException(&quot;There is no index registered on the database Db&lt;&quot;+this.emptyInstance.getClass().getSimpleName()+&quot;&gt; with a name of \&quot;&quot;+indexName+&quot;\&quot;&quot;);</span>
        }
<span class="fc" id="L363">        Set&lt;T&gt; values = registeredIndexes.get(indexName).get(key);</span>
        // return an empty set rather than null
<span class="fc" id="L365">        return Objects.requireNonNullElseGet(values, Set::of);</span>
    }

    /**
     * Get a set of the currently-registered indexes on this database, useful
     * for debugging.
     */
    public Set&lt;String&gt; getSetOfIndexes() {
<span class="fc" id="L373">        return partitioningMap.keySet();</span>
    }

    /**
     * A utility to find exactly one item from the database.
     * &lt;br&gt;
     * This utility will search the indexes for a particular data by
     * indexName and indexKey.  If not found, it will return null. If
     * found, it will be returned. If more than one are found, an exception
     * will be thrown.  Use this tool when the data has been uniquely
     * indexed, like for example when setting a unique identifier into
     * each data.
     * @param indexName the name of the index, an arbitrary value set by the
     *                  user to help distinguish among potentially many indexes
     *                  set on this data
     * @param indexKey the key for this particular value, such as a UUID or a name
     *                 or any other way to partition the data
     * @see #findExactlyOne(String, String, Callable)
     */
    public T findExactlyOne(String indexName, String indexKey) {
<span class="fc" id="L393">        return findExactlyOne(indexName, indexKey, () -&gt; null);</span>
    }

    /**
     * Find one item, with an alternate value if null
     * &lt;br&gt;
     * This utility will search the indexes for a particular data by
     * indexName and indexKey.  If not found, it will return null. If
     * found, it will be returned. If more than one are found, an exception
     * will be thrown.  Use this tool when the data has been uniquely
     * indexed, like for example when setting a unique identifier into
     * each data.
     * @param indexName the name of the index, an arbitrary value set by the
     *                  user to help distinguish among potentially many indexes
     *                  set on this data
     * @param indexKey the key for this particular value, such as a UUID or a name
     *                 or any other way to partition the data
     * @param alternate a functional interface that will be run if the result would
     *                  have been null, useful for situations where you don't want
     *                  the output to be null when nothing is found.
     * @see #findExactlyOne(String, String)
     */
    public T findExactlyOne(String indexName, String indexKey, Callable&lt;T&gt; alternate) {
<span class="fc" id="L416">        Collection&lt;T&gt; indexedData = getIndexedData(indexName, indexKey);</span>
<span class="fc bfc" id="L417" title="All 2 branches covered.">        if (indexedData.isEmpty()) {</span>
            try {
<span class="fc" id="L419">                return alternate.call();</span>
<span class="fc" id="L420">            } catch (Exception ex) {</span>
<span class="fc" id="L421">                throw new DbException(ex);</span>
            }
<span class="fc bfc" id="L423" title="All 2 branches covered.">        } else if (indexedData.size() == 1) {</span>
<span class="fc" id="L424">            return indexedData.stream().findFirst().orElseThrow();</span>
        } else {
<span class="fc" id="L426">            throw new DbException(&quot;More than one item found when searching database Db&lt;%s&gt; on index \&quot;%s\&quot; with key %s&quot;</span>
<span class="fc" id="L427">                    .formatted(emptyInstance.getClass().getSimpleName(), indexName, indexKey));</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>
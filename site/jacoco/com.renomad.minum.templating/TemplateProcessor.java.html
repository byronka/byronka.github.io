<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>TemplateProcessor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">minum</a> &gt; <a href="index.source.html" class="el_package">com.renomad.minum.templating</a> &gt; <span class="el_source">TemplateProcessor.java</span></div><h1>TemplateProcessor.java</h1><pre class="source lang-java linenums">package com.renomad.minum.templating;

import java.util.*;
import java.util.stream.Collectors;

import static com.renomad.minum.utils.SerializationUtils.tokenizer;

/**
 * This class provides methods for working with templates.
 * &lt;p&gt;
 * The first step is to write a template.  Here is an example:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * Hello, my name is {{name}}
 * &lt;/pre&gt;
 * &lt;p&gt;
 * Then, feed that string into the {@link #buildProcessor} method, like
 * this:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * {@code
 *   String input = &quot;Hello, my name is {{name}}&quot;
 *   TemplateProcessor helloProcessor = TemplateProcessor.buildProcessor(input);
 * }
 * &lt;/pre&gt;
 * &lt;p&gt;
 * The returned value (&quot;helloProcessor&quot;) can be rendered with different values. For
 * example:
 * &lt;/p&gt;
 * &lt;pre&gt;
 * {@code
 *   Map&lt;String,String&gt; myMap = Map.of(&quot;name&quot;, &quot;Susanne&quot;);
 *   String fullyRenderedString = helloProcessor.renderTemplate(myMap);
 * }
 * &lt;/pre&gt;
 * &lt;p&gt;
 *     The result is:
 * &lt;/p&gt;
 * &lt;pre&gt;
 *     {@code Hello, my name is Susanne}
 * &lt;/pre&gt;
 */
public final class TemplateProcessor {

    /**
     * template sections by indentation
     */
    private Map&lt;Integer, List&lt;TemplateSection&gt;&gt; templatesSectionsByIndent;
<span class="fc" id="L49">    private List&lt;Map&lt;String, String&gt;&gt; dataList = new ArrayList&lt;&gt;();</span>
    private final Set&lt;String&gt; keysFoundInTemplate;
    private final Set&lt;String&gt; keysRegisteredForInnerTemplates;
    private final String originalText;
    /**
     * This value is used to calculate a quick estimate of how many
     * bytes of memory we will need for the buffer holding our generated string
     */
    private final static double SIZE_ESTIMATE_MODIFIER = 1.1;
    private final int estimatedSize;
    private Map&lt;String, TemplateProcessor&gt; innerTemplates;

    /**
     * Instantiate a new object with a list of {@link TemplateSection}.
     */
<span class="fc" id="L64">    private TemplateProcessor(List&lt;TemplateSection&gt; templateSections, String originalText) {</span>
<span class="fc" id="L65">        this.templatesSectionsByIndent = new HashMap&lt;&gt;();</span>
<span class="fc" id="L66">        this.templatesSectionsByIndent.put(0, templateSections);</span>
<span class="fc" id="L67">        keysFoundInTemplate = new HashSet&lt;&gt;();</span>
<span class="fc" id="L68">        keysRegisteredForInnerTemplates = new HashSet&lt;&gt;();</span>
<span class="fc" id="L69">        this.originalText = originalText;</span>
<span class="fc" id="L70">        this.innerTemplates = new HashMap&lt;&gt;();</span>
<span class="fc" id="L71">        estimatedSize = (int) Math.round(originalText.length() * SIZE_ESTIMATE_MODIFIER);</span>
<span class="fc" id="L72">    }</span>

    /**
     * Given a map of key names -&gt; value, render a template.
     */
    public String renderTemplate(Map&lt;String, String&gt; myMap) {
<span class="fc" id="L78">        registerData(List.of(myMap));</span>

<span class="fc" id="L80">        return internalRender(true).toString();</span>
    }

    /**
     * Given a list of maps of key names -&gt; value, render a template
     * multiple times.
     */
    public String renderTemplate(List&lt;Map&lt;String, String&gt;&gt; myMap) {
<span class="fc" id="L88">        registerData(myMap);</span>

<span class="fc" id="L90">        return internalRender(true).toString();</span>
    }

    /**
     * Recursively assembles the template and sub-templates
     */
    public String renderTemplate() {
<span class="fc" id="L97">        return internalRender(true).toString();</span>
    }

    /**
     * Render the template and any nested sub-templates.  All templates
     * must have data registered before running this method.
     * @param runWithChecks Default: true.  Check that there is a 1-to-1 correspondence between
     *                      the keys provided and keys in the template and sub-templates, throwing
     *                      an exception if there are any errors. Also check that the maps
     *                      of data are consistent.  This should be set true unless there is a reason
     *                      to aim for maximum performance, which is actually not
     *                      valuable in most cases, since the bottleneck is the business algorithms, database,
     *                      and HTTP processing.
     */
    public String renderTemplate(boolean runWithChecks) {
<span class="fc" id="L112">        return internalRender(runWithChecks).toString();</span>
    }

    /**
     * Assign data.  Keys must match to template.
     */
    public void registerData(List&lt;Map&lt;String, String&gt;&gt; dataList) {
<span class="fc bfc" id="L119" title="All 2 branches covered.">        if (dataList == null){</span>
<span class="fc" id="L120">            throw new TemplateRenderException(&quot;provided data cannot be null&quot;);</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">        } else if (dataList.isEmpty()) {</span>
<span class="fc" id="L122">            throw new TemplateRenderException(&quot;No data provided in registerData call&quot;);</span>
        }

<span class="fc" id="L125">        this.dataList = dataList;</span>
<span class="fc" id="L126">    }</span>

    /**
     * Builds a {@link TemplateProcessor} from a string
     * containing a proper template.  Templated values
     * are surrounded by double-curly-braces, i.e. {{foo}} or {{ foo }}
     */
    public static TemplateProcessor buildProcessor(String template) {
<span class="fc bfc" id="L134" title="All 4 branches covered.">        if (template == null || template.isEmpty()) {</span>
<span class="fc" id="L135">            throw new TemplateRenderException(&quot;The input to building a template must be a non-empty string&quot;);</span>
        }
<span class="fc" id="L137">        var tp = new TemplateProcessor(new ArrayList&lt;&gt;(), template);</span>
<span class="fc" id="L138">        List&lt;TemplateSection&gt; tSections = tp.renderToTemplateSections(template);</span>
<span class="fc" id="L139">        Set&lt;String&gt; keysFound = tSections.stream()</span>
<span class="fc" id="L140">                .filter(x -&gt; x.templateType.equals(TemplateType.DYNAMIC_TEXT))</span>
<span class="fc" id="L141">                .map(x -&gt; x.key)</span>
<span class="fc" id="L142">                .collect(Collectors.toSet());</span>
<span class="fc" id="L143">        tp.keysFoundInTemplate.addAll(keysFound);</span>
<span class="fc" id="L144">        tp.templatesSectionsByIndent.put(0, tSections);</span>

<span class="fc" id="L146">        return tp;</span>
    }

    private ArrayList&lt;TemplateSection&gt; renderToTemplateSections(String template) {
        // this value holds the entire template after processing, comprised
        // of an ordered list of TemplateSections
<span class="fc" id="L152">        var tSections = new ArrayList&lt;TemplateSection&gt;();</span>

        // these values are used for logging and setting proper indentation
<span class="fc" id="L155">        int rowNumber = 1;</span>
<span class="fc" id="L156">        int columnNumber = 1;</span>
        // this value records the indent of the beginning of template keys,
        // so we can properly indent the values later.
<span class="fc" id="L159">        int startOfKey = 0;</span>

<span class="fc" id="L161">        StringBuilder builder = new StringBuilder();</span>
        // this flag is to help us understand whether we are currently reading the
        // name of a template literal.
        // e.g. in the case of hello {{ name }}, &quot;name&quot; is the literal.
<span class="fc" id="L165">        boolean isInsideTemplateKeyLiteral = false;</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">        for (int i = 0; i &lt; template.length(); i++) {</span>
<span class="fc" id="L167">            char charAtCursor = template.charAt(i);</span>

<span class="fc bfc" id="L169" title="All 6 branches covered.">            if (charAtCursor == '{' &amp;&amp; (i + 1) &lt; template.length() &amp;&amp; template.charAt(i + 1) == '{') {</span>
<span class="fc" id="L170">                isInsideTemplateKeyLiteral = true;</span>
<span class="fc" id="L171">                startOfKey = columnNumber - 1;</span>
<span class="fc" id="L172">                i += 1;</span>
<span class="fc" id="L173">                builder = processSectionInside(builder, tSections);</span>
<span class="fc bfc" id="L174" title="All 8 branches covered.">            } else if (isInsideTemplateKeyLiteral &amp;&amp; charAtCursor == '}' &amp;&amp; (i + 1) &lt; template.length() &amp;&amp; template.charAt(i + 1) == '}') {</span>
<span class="fc" id="L175">                isInsideTemplateKeyLiteral = false;</span>
<span class="fc" id="L176">                i += 1;</span>
<span class="fc" id="L177">                builder = processSectionOutside(builder, tSections, startOfKey);</span>
<span class="fc" id="L178">                startOfKey = 0;</span>
            } else {
<span class="fc" id="L180">                builder.append(charAtCursor);</span>

                /*
                 if we're at the end of the template, it's our last chance to
                 add a substring (we can't be adding to a key, since if we're
                 at the end, and it's not a closing brace, it's a malformed
                 template.
                 */
<span class="fc bfc" id="L188" title="All 2 branches covered.">                if (i == template.length() - 1) {</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">                    if (isInsideTemplateKeyLiteral) {</span>
                        // if we're exiting this string while inside a template literal, then
                        // we're reading a corrupted input, and we should make that clear
                        // to our caller.
<span class="fc bfc" id="L193" title="All 2 branches covered.">                        String templateSample = template.length() &gt; 10 ? template.substring(0, 10) + &quot;...&quot; : template;</span>
<span class="fc" id="L194">                        throw new TemplateParseException(</span>
                                &quot;parsing failed for string starting with \&quot;&quot; + templateSample + &quot;\&quot; at line &quot; + rowNumber + &quot; and column &quot; + columnNumber);
                    }
<span class="fc" id="L197">                    tSections.add(new TemplateSection(null, builder.toString(), null, TemplateType.STATIC_TEXT, 0));</span>
                }
            }

<span class="fc bfc" id="L201" title="All 2 branches covered.">            if (charAtCursor == '\n') {</span>
<span class="fc" id="L202">                rowNumber += 1;</span>
<span class="fc" id="L203">                columnNumber = 1;</span>
            } else {
<span class="fc" id="L205">                columnNumber += 1;</span>
            }

        }
<span class="fc" id="L209">        return tSections;</span>
    }

    private static StringBuilder processSectionInside(StringBuilder builder, List&lt;TemplateSection&gt; tSections) {
<span class="fc bfc" id="L213" title="All 2 branches covered.">        if (!builder.isEmpty()) {</span>
<span class="fc" id="L214">            tSections.add(new TemplateSection(null, builder.toString(), null, TemplateType.STATIC_TEXT, 0));</span>
<span class="fc" id="L215">            builder = new StringBuilder();</span>
        }
<span class="fc" id="L217">        return builder;</span>
    }

    private static StringBuilder processSectionOutside(StringBuilder builder,
                                               List&lt;TemplateSection&gt; tSections,
                                               int indent) {
<span class="fc" id="L223">        String key = builder.toString().trim();</span>
<span class="fc" id="L224">        tSections.add(new TemplateSection(key, &quot;&quot;, null, TemplateType.DYNAMIC_TEXT, indent));</span>
<span class="fc" id="L225">        builder = new StringBuilder();</span>
<span class="fc" id="L226">        return builder;</span>
    }

    /**
     * Binds an inner template to a key of this template.
     */
    public TemplateProcessor registerInnerTemplate(String key, TemplateProcessor innerTemplate) {
<span class="fc bfc" id="L233" title="All 4 branches covered.">        if (key == null || key.isBlank()) {</span>
<span class="fc" id="L234">            throw new TemplateRenderException(&quot;The key must be a valid non-blank string&quot;);</span>
        }
<span class="fc bfc" id="L236" title="All 2 branches covered.">        if (innerTemplate == null) {</span>
<span class="fc" id="L237">            throw new TemplateRenderException(&quot;The template must not be null&quot;);</span>
        }
<span class="fc bfc" id="L239" title="All 2 branches covered.">        if (this.equals(innerTemplate)) {</span>
<span class="fc" id="L240">            throw new TemplateRenderException(&quot;Disallowed to register a template to itself as an inner template&quot;);</span>
        }
<span class="fc bfc" id="L242" title="All 2 branches covered.">        if (keysRegisteredForInnerTemplates.contains(key)) {</span>
<span class="fc" id="L243">            throw new TemplateRenderException(&quot;key is already registered for use in another template: &quot; + key);</span>
        }

        // get the indent we should apply to each line after the first
        // by seeing what indent exists in the template sections and
        // creating a separate indented version for each one
<span class="fc" id="L249">        Set&lt;Integer&gt; necessaryIndentations = this.templatesSectionsByIndent.get(0).stream()</span>
<span class="fc" id="L250">                .filter(x -&gt; key.equals(x.key))</span>
<span class="fc" id="L251">                .map(x -&gt; x.indent).collect(Collectors.toSet());</span>

        // make sure we have one for zero as well.
<span class="fc" id="L254">        necessaryIndentations.add(0);</span>


<span class="fc" id="L257">        var copyOfInnerTemplate = new TemplateProcessor(innerTemplate.templatesSectionsByIndent.get(0), innerTemplate.getOriginalText());</span>
<span class="fc" id="L258">        copyOfInnerTemplate.keysFoundInTemplate.addAll(innerTemplate.keysFoundInTemplate);</span>
<span class="fc" id="L259">        copyOfInnerTemplate.keysRegisteredForInnerTemplates.addAll(innerTemplate.keysRegisteredForInnerTemplates);</span>
<span class="fc" id="L260">        copyOfInnerTemplate.innerTemplates = new HashMap&lt;&gt;(innerTemplate.innerTemplates);</span>
<span class="fc" id="L261">        this.innerTemplates.put(key, copyOfInnerTemplate);</span>

<span class="fc" id="L263">        copyOfInnerTemplate.templatesSectionsByIndent.clear();</span>

        // a non-configurable ceiling limit to avoid runaway loops
<span class="fc" id="L266">        int MAXIMUM_LINES_ALLOWED = 10_000_000;</span>
<span class="fc" id="L267">        String originalText = copyOfInnerTemplate.getOriginalText();</span>
<span class="fc" id="L268">        List&lt;String&gt; lines = tokenizer(originalText, '\n', MAXIMUM_LINES_ALLOWED);</span>

        // if, after splitting on newlines, we have more than one line, we'll indent the remaining
        // lines so that they end up at the same column as the first line.
<span class="fc bfc" id="L272" title="All 2 branches covered.">        for (int indentation : necessaryIndentations) {</span>
<span class="fc" id="L273">            var indentedInnerTemplateText = new StringBuilder(lines.getFirst());</span>
<span class="fc bfc" id="L274" title="All 2 branches covered.">            for (int i = 1; i &lt; lines.size(); i++) {</span>
<span class="fc bfc" id="L275" title="All 2 branches covered.">                if (lines.get(i).isEmpty()) {</span>
<span class="fc" id="L276">                    indentedInnerTemplateText.append('\n');</span>
                } else {
<span class="fc" id="L278">                    indentedInnerTemplateText.append('\n').append(&quot; &quot;.repeat(indentation)).append(lines.get(i));</span>
                }
            }
<span class="fc" id="L281">            List&lt;TemplateSection&gt; tSections = renderToTemplateSections(indentedInnerTemplateText.toString());</span>
<span class="fc" id="L282">            copyOfInnerTemplate.templatesSectionsByIndent.put(indentation, tSections);</span>

            // now, loop through all the template sections, replacing them appropriately with
            // new data labeled as INNER_TEMPLATE.
<span class="fc" id="L286">            Map&lt;Integer, List&lt;TemplateSection&gt;&gt; revisedTemplateSectionsByIndent = new HashMap&lt;&gt;();</span>
<span class="fc bfc" id="L287" title="All 2 branches covered.">            for (var templateSectionsByIndent : templatesSectionsByIndent.entrySet()) {</span>
<span class="fc" id="L288">                List&lt;TemplateSection&gt; revisedList = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L289" title="All 2 branches covered.">                for (TemplateSection templateSection : templateSectionsByIndent.getValue()) {</span>
<span class="fc bfc" id="L290" title="All 2 branches covered.">                    if (key.equals(templateSection.key)) {</span>
<span class="fc" id="L291">                        revisedList.add(new TemplateSection(templateSection.key,</span>
                                templateSection.staticData,
                                copyOfInnerTemplate,
                                TemplateType.INNER_TEMPLATE,
                                templateSection.indent));
                    } else {
<span class="fc" id="L297">                        revisedList.add(templateSection);</span>
                    }
<span class="fc" id="L299">                }</span>
<span class="fc" id="L300">                revisedTemplateSectionsByIndent.put(templateSectionsByIndent.getKey(), revisedList);</span>
<span class="fc" id="L301">            }</span>
<span class="fc" id="L302">            templatesSectionsByIndent = revisedTemplateSectionsByIndent;</span>

<span class="fc" id="L304">            this.keysRegisteredForInnerTemplates.add(key);</span>
<span class="fc" id="L305">        }</span>

<span class="fc" id="L307">        return copyOfInnerTemplate;</span>
    }

    /**
     * Returns the original unchanged template string
     */
    public String getOriginalText() {
<span class="fc" id="L314">        return originalText;</span>
    }

    /**
     * now, loop through the lists of data we were given, with the
     * internal template sections in hand
     */
    private StringBuilder internalRender(boolean runWithChecks) {
<span class="fc bfc" id="L322" title="All 2 branches covered.">        if (runWithChecks) {</span>
<span class="fc" id="L323">            correctnessCheck();</span>
        }
<span class="fc" id="L325">        int capacity = calculateEstimatedSize();</span>
<span class="fc" id="L326">        StringBuilder parts = new StringBuilder(capacity);</span>
<span class="fc" id="L327">        return internalRender(0, parts);</span>
    }

    /**
     * This examines the currently registered data lists and template keys
     * and confirms they are aligned.  It will throw an exception if they
     * are not perfectly correlated.
     * &lt;br&gt;
     *
     */
    private void correctnessCheck() {
<span class="fc" id="L338">        HashSet&lt;String&gt; copyOfKeysInTemplate = new HashSet&lt;&gt;(keysFoundInTemplate);</span>
<span class="fc" id="L339">        copyOfKeysInTemplate.removeAll(this.innerTemplates.keySet());</span>

<span class="fc bfc" id="L341" title="All 2 branches covered.">        if (this.dataList.isEmpty()) {</span>
<span class="fc bfc" id="L342" title="All 2 branches covered.">            if (!copyOfKeysInTemplate.isEmpty()) {</span>
                // at this point we know there is no data provided but the template
                // requires data, so throw an exception.

<span class="fc" id="L346">                throw new TemplateRenderException(&quot;No data was provided for these keys: &quot; + copyOfKeysInTemplate);</span>
            }
        } else {

            // check for inconsistencies between maps in the data list
<span class="fc" id="L351">            Set&lt;String&gt; keysInFirstMap = this.dataList.getFirst().keySet();</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">            for (Map&lt;String, String&gt; data : this.dataList) {</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">                if (!data.keySet().equals(keysInFirstMap)) {</span>
<span class="fc" id="L354">                    Set&lt;String&gt; result = differenceBetweenSets(data.keySet(), keysInFirstMap);</span>
<span class="fc" id="L355">                    throw new TemplateRenderException(&quot;In registered data, the maps were inconsistent on these keys: &quot; + result);</span>
                }
<span class="fc" id="L357">            }</span>

            // ensure consistency between the registered data and the template keys
<span class="fc" id="L360">            HashSet&lt;String&gt; copyOfTemplateKeys = new HashSet&lt;&gt;(copyOfKeysInTemplate);</span>
<span class="fc" id="L361">            copyOfTemplateKeys.removeAll(keysInFirstMap);</span>
<span class="fc bfc" id="L362" title="All 2 branches covered.">            if (!copyOfTemplateKeys.isEmpty()) {</span>
<span class="fc" id="L363">                throw new TemplateRenderException(&quot;These keys in the template were not provided data: &quot; + copyOfTemplateKeys);</span>
            }

<span class="fc" id="L366">            HashSet&lt;String&gt; copyOfDataKeys = new HashSet&lt;&gt;(keysInFirstMap);</span>
<span class="fc" id="L367">            copyOfDataKeys.removeAll(copyOfKeysInTemplate);</span>
<span class="fc bfc" id="L368" title="All 2 branches covered.">            if (!copyOfDataKeys.isEmpty()) {</span>
<span class="fc" id="L369">                throw new TemplateRenderException(&quot;These keys in the data did not match anything in the template: &quot; + copyOfDataKeys);</span>
            }
        }

<span class="fc bfc" id="L373" title="All 2 branches covered.">        for (TemplateProcessor tp : this.innerTemplates.values()) {</span>
<span class="fc" id="L374">            tp.correctnessCheck();</span>
<span class="fc" id="L375">        }</span>

<span class="fc" id="L377">    }</span>

    private static Set&lt;String&gt; differenceBetweenSets(Set&lt;String&gt; set1, Set&lt;String&gt; set2) {
<span class="fc" id="L380">        Set&lt;String&gt; union = new HashSet&lt;&gt;(set2);</span>
<span class="fc" id="L381">        union.addAll(set1);</span>
<span class="fc" id="L382">        Set&lt;String&gt; intersection = new HashSet&lt;&gt;(set2);</span>
<span class="fc" id="L383">        intersection.retainAll(set1);</span>

<span class="fc" id="L385">        Set&lt;String&gt; result = new HashSet&lt;&gt;(union);</span>
<span class="fc" id="L386">        result.removeAll(intersection);</span>
<span class="fc" id="L387">        return result;</span>
    }

    /**
     * build up a calculated size estimate for this and all
     * nested templates.
     */
    private int calculateEstimatedSize() {
        // the size of the datalist specifies how many times we will render ourselves.
<span class="fc bfc" id="L396" title="All 2 branches covered.">        int sizeMultiplier = this.dataList.isEmpty() ? 1 : this.dataList.size();</span>
<span class="fc" id="L397">        int fullCalculatedSize = sizeMultiplier * estimatedSize;</span>
<span class="fc bfc" id="L398" title="All 2 branches covered.">        for (TemplateProcessor innerProcessor : this.innerTemplates.values()) {</span>
<span class="fc" id="L399">            fullCalculatedSize += innerProcessor.calculateEstimatedSize();</span>
<span class="fc" id="L400">        }</span>
<span class="fc" id="L401">        return fullCalculatedSize;</span>
    }

    private StringBuilder internalRender(int indent, StringBuilder parts) {
<span class="fc" id="L405">        Map&lt;String, String&gt; myDataMap = Map.of();</span>
<span class="fc" id="L406">        List&lt;TemplateSection&gt; templateSections = templatesSectionsByIndent.get(indent);</span>
<span class="fc" id="L407">        int templateSectionsSize = templateSections.size();</span>
<span class="fc" id="L408">        int dataListIndex = 0;</span>
<span class="fc bfc" id="L409" title="All 2 branches covered.">        if (!dataList.isEmpty()) {</span>
<span class="fc" id="L410">            myDataMap = dataList.get(dataListIndex);</span>
        }

        // build ourself out for each map of data given
        while (true) {
<span class="fc bfc" id="L415" title="All 2 branches covered.">            for (int i = 0; i &lt; templateSectionsSize; i++) {</span>
<span class="fc" id="L416">                TemplateSection templateSection = templateSections.get(i);</span>
<span class="fc bfc" id="L417" title="All 3 branches covered.">                switch (templateSection.templateType) {</span>
<span class="fc" id="L418">                    case STATIC_TEXT -&gt; parts.append(templateSection.staticData);</span>
<span class="fc" id="L419">                    case DYNAMIC_TEXT -&gt; parts.append(myDataMap.get(templateSection.key));</span>
<span class="fc" id="L420">                    default -&gt; templateSection.templateProcessor.internalRender(templateSection.indent, parts);</span>
                }

            }
<span class="fc" id="L424">            dataListIndex += 1;</span>
<span class="fc bfc" id="L425" title="All 4 branches covered.">            if (!dataList.isEmpty() &amp;&amp; dataListIndex &lt; dataList.size()) {</span>
<span class="fc" id="L426">                myDataMap = dataList.get(dataListIndex);</span>
<span class="fc" id="L427">                parts.append(&quot;\n&quot;).repeat(&quot; &quot;, indent);</span>
            } else {
<span class="fc" id="L429">                return parts;</span>
            }
        }
    }

    /**
     * Returns the reference to an inner template, to enable registering
     * data and sub-templates.
     */
    public TemplateProcessor getInnerTemplate(String innerTemplateKey) {
<span class="fc" id="L439">        return this.innerTemplates.get(innerTemplateKey);</span>
    }
}

</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>
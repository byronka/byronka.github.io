<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>StreamingMultipartPartition.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">minum</a> &gt; <a href="index.source.html" class="el_package">com.renomad.minum.web</a> &gt; <span class="el_source">StreamingMultipartPartition.java</span></div><h1>StreamingMultipartPartition.java</h1><pre class="source lang-java linenums">package com.renomad.minum.web;


import com.renomad.minum.utils.RingBuffer;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.nio.charset.StandardCharsets;
import java.util.List;
import java.util.stream.IntStream;

/**
 * This class represents a single partition in a multipart/form
 * Request body, when read as an InputStream.  This enables the
 * developer to pull data incrementally, rather than reading it
 * all into memory at once.
 */
public class StreamingMultipartPartition extends InputStream {

    private final Headers headers;
    private final InputStream inputStream;
    private final ContentDisposition contentDisposition;
    private final int contentLength;
    /**
     * After we hit the boundary, we will set this flag to true, and all
     * subsequent reads will return -1.
     */
<span class="fc" id="L29">    private boolean isFinished = false;</span>

    /**
     * This buffer follows along with what we are reading, so we can
     * easily compare against our boundary value.  There are four extra
     * bytes included, since multipart splits the content by two
     * dashes, followed by the boundary value, and then two dashes afterwards
     * on the last boundary.
     * &lt;pre&gt;
     * That is,
     * for a typical boundary:
     *
     *   --boundary_value
     *
     * and for the last boundary:
     *
     *   --boundary_value--
     *&lt;/pre&gt;
     */
    private final RingBuffer&lt;Byte&gt; recentBytesBuffer;
    private final CountBytesRead countBytesRead;
    private final List&lt;Byte&gt; boundaryValueList;
    private boolean hasFilledBuffer;

    /**
     * @param contentLength the length specified by the Content-Length header, it is
     *                      the overall length of the body
     */
    StreamingMultipartPartition(Headers headers,
                                       InputStream inputStream,
                                       ContentDisposition contentDisposition,
                                       String boundaryValue,
                                       CountBytesRead countBytesRead,
<span class="fc" id="L62">                                       int contentLength) {</span>

<span class="fc" id="L64">        this.headers = headers;</span>
<span class="fc" id="L65">        this.inputStream = inputStream;</span>
<span class="fc" id="L66">        this.contentDisposition = contentDisposition;</span>
<span class="fc" id="L67">        this.contentLength = contentLength;</span>
<span class="fc" id="L68">        String boundaryValue1 = &quot;\r\n--&quot; + boundaryValue;</span>
<span class="fc" id="L69">        byte[] bytes = boundaryValue1.getBytes(StandardCharsets.US_ASCII);</span>
<span class="fc" id="L70">        boundaryValueList = IntStream.range(0, bytes.length).mapToObj(i -&gt; bytes[i]).toList();</span>

        /*
         * To explain the numbers here: we add one at the beginning to represent
         * the single character at the far left that is what we will actually return.
         * We have to fill the cache before we start sending anything.  The number
         * at the end represents the extra characters of the boundary - dashes,
         * carriage return, newline.
         */
<span class="fc" id="L79">        recentBytesBuffer = new RingBuffer&lt;&gt;(boundaryValue1.length(), Byte.class);</span>
<span class="fc" id="L80">        this.countBytesRead = countBytesRead;</span>
<span class="fc" id="L81">    }</span>

    public Headers getHeaders() {
<span class="fc" id="L84">        return headers;</span>
    }

    public ContentDisposition getContentDisposition() {
<span class="fc" id="L88">        return contentDisposition;</span>
    }


    /**
     * Reads from the inputstream using a buffer for checking whether we've
     * hit the end of a multpart partition.
     * @return -1 if we're at the end of a partition
     * @throws IOException if the inputstream is closed unexpectedly while reading.
     */
    @Override
    public int read() throws IOException {
<span class="fc bfc" id="L100" title="All 2 branches covered.">        if (isFinished) {</span>
<span class="fc" id="L101">            return -1;</span>
        }
<span class="fc bfc" id="L103" title="All 2 branches covered.">        if (!hasFilledBuffer) {</span>
<span class="fc" id="L104">            fillBuffer();</span>
<span class="fc" id="L105">            boolean atTheEnd = recentBytesBuffer.containsAt(boundaryValueList, 0);</span>
<span class="fc bfc" id="L106" title="All 2 branches covered.">            if (atTheEnd) {</span>
                // don't really do anything with this, it's just to collect the
                // last characters to have a clean finish.
<span class="fc" id="L109">                byte[] unused = inputStream.readNBytes(2);</span>
<span class="fc" id="L110">                isFinished = true;</span>
<span class="fc" id="L111">                return -1;</span>
            }
<span class="fc" id="L113">        } else {</span>
<span class="fc" id="L114">            int result = inputStream.read();</span>
<span class="fc" id="L115">            countBytesRead.increment();</span>
<span class="fc bfc" id="L116" title="All 2 branches covered.">            if (countBytesRead.getCount() &gt;= contentLength) {</span>
<span class="fc" id="L117">                isFinished = true;</span>
<span class="fc" id="L118">                return -1;</span>
            }
<span class="fc bfc" id="L120" title="All 2 branches covered.">            if (result == -1) {</span>
<span class="fc" id="L121">                throw new IOException(&quot;Error: The inputstream has closed unexpectedly while reading&quot;);</span>
            }
<span class="fc" id="L123">            byte byteValue = (byte) result;</span>
<span class="fc" id="L124">            boolean isAtEndOfPartition = updateRecentBytesBufferAndCheck(byteValue);</span>
<span class="fc bfc" id="L125" title="All 2 branches covered.">            if (isAtEndOfPartition) {</span>
                // don't really do anything with this, it's just to collect the
                // last characters to have a clean finish.
<span class="fc" id="L128">                byte[] unused = inputStream.readNBytes(2);</span>
<span class="fc" id="L129">                isFinished = true;</span>
<span class="fc" id="L130">                return -1;</span>
            }

        }
<span class="fc" id="L134">        return ((int)recentBytesBuffer.atNextIndex()) &amp; 0xff;</span>
    }

    private void fillBuffer() throws IOException {
<span class="fc bfc" id="L138" title="All 2 branches covered.">        for (int i = 0; i &lt; recentBytesBuffer.getLimit(); i++) {</span>
<span class="fc" id="L139">            int result = inputStream.read();</span>
<span class="fc" id="L140">            countBytesRead.increment();</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">            if (result == -1) {</span>
<span class="fc" id="L142">                throw new IOException(&quot;Error: The inputstream has closed unexpectedly while reading&quot;);</span>
            }
<span class="fc" id="L144">            byte byteValue = (byte) result;</span>
<span class="fc" id="L145">            updateRecentBytesBufferAndCheck(byteValue);</span>
        }
<span class="fc" id="L147">        hasFilledBuffer = true;</span>
<span class="fc" id="L148">    }</span>

    @Override
    public byte[] readAllBytes()  {
<span class="fc" id="L152">        var baos = new ByteArrayOutputStream();</span>
        while (true) {
<span class="fc" id="L154">            int result = 0;</span>
            try {
<span class="fc" id="L156">                result = read();</span>
<span class="fc" id="L157">            } catch (IOException e) {</span>
<span class="fc" id="L158">                throw new WebServerException(e);</span>
<span class="fc" id="L159">            }</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">            if (result == -1) {</span>
<span class="fc" id="L161">                return baos.toByteArray();</span>
            }
<span class="fc" id="L163">            baos.write((byte)result);</span>
<span class="fc" id="L164">        }</span>
    }

    /**
     * Updates the buffer with the last characters read, and returns
     * true if we have encountered the end of this partition.
     */
    private boolean updateRecentBytesBufferAndCheck(byte newByte) {
<span class="fc" id="L172">        recentBytesBuffer.add(newByte);</span>
<span class="fc" id="L173">        return recentBytesBuffer.containsAt(boundaryValueList, 0);</span>
    }

    /**
     * By &quot;close&quot;, we will read from the {@link InputStream} until we have finished the body,
     * so that our InputStream has been read until the start of the next partition.
     */
    @Override
    public void close() throws IOException {
        while (true) {
<span class="fc" id="L183">            int result = read();</span>
<span class="fc bfc" id="L184" title="All 2 branches covered.">            if (result == -1) {</span>
<span class="fc" id="L185">                return;</span>
            }
<span class="fc" id="L187">        }</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>
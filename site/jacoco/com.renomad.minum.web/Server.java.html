<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Server.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">minum</a> &gt; <a href="index.source.html" class="el_package">com.renomad.minum.web</a> &gt; <span class="el_source">Server.java</span></div><h1>Server.java</h1><pre class="source lang-java linenums">package com.renomad.minum.web;

import com.renomad.minum.logging.ILogger;
import com.renomad.minum.state.Constants;
import com.renomad.minum.state.Context;
import com.renomad.minum.utils.ConcurrentSet;
import com.renomad.minum.utils.StacktraceUtils;
import com.renomad.minum.utils.ThrowingRunnable;

import java.io.IOException;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Future;
import java.util.concurrent.LinkedBlockingQueue;

import static com.renomad.minum.utils.ThrowingRunnable.throwingRunnableWrapper;

/**
 * The purpose here is to make it marginally easier to
 * work with a ServerSocket.
 * &lt;p&gt;
 * First, instantiate this class using a running serverSocket
 * Then, by running the start method, we gain access to
 * the server's socket.  This way we can easily test / control
 * the server side but also tie it in with an ExecutorService
 * for controlling lots of server threads.
 */
final class Server implements IServer {
    private final ServerSocket serverSocket;
    private final SetOfSws setOfSWs;
    private final ExecutorService es;
    private final HttpServerType serverType;
    private final ILogger logger;
    private final String serverName;
    private final WebFramework webFramework;
    private final BlockingQueue&lt;Socket&gt; socketQueue;
    private final Constants constants;

    /**
     * This is the future returned when we submitted the
     * thread for the central server loop to the ExecutorService
     */
    private Future&lt;?&gt; centralLoopFuture;

<span class="fc" id="L47">    Server(ServerSocket ss, Context context, String serverName, WebFramework webFramework, ExecutorService es, HttpServerType serverType) {</span>
<span class="fc" id="L48">        this.serverSocket = ss;</span>
<span class="fc" id="L49">        this.logger = context.getLogger();</span>
<span class="fc" id="L50">        this.constants = context.getConstants();</span>
<span class="fc" id="L51">        this.webFramework = webFramework;</span>
<span class="fc" id="L52">        this.serverName = serverName;</span>
<span class="fc" id="L53">        setOfSWs = new SetOfSws(new ConcurrentSet&lt;&gt;(), logger, serverName);</span>
<span class="fc" id="L54">        this.es = es;</span>
<span class="fc" id="L55">        this.serverType = serverType;</span>
<span class="fc" id="L56">        this.socketQueue = new LinkedBlockingQueue&lt;&gt;();</span>
<span class="fc" id="L57">    }</span>

    @Override
    public void start() {
<span class="fc" id="L61">        ThrowingRunnable serverCode = this::outermostLoop;</span>
<span class="fc" id="L62">        this.centralLoopFuture = es.submit(throwingRunnableWrapper(serverCode, logger));</span>

<span class="fc" id="L64">        ThrowingRunnable socketHandler = this::takeOffDequeForProcessing;</span>
<span class="fc" id="L65">        es.submit(throwingRunnableWrapper(socketHandler, logger));</span>
<span class="fc" id="L66">    }</span>

    /**
     * This code is the outermost loop of the server, waiting for incoming
     * connections and then delegating their handling off to a handler.
     */
    private void outermostLoop() {
<span class="fc" id="L73">        Thread.currentThread().setName(&quot;Main Server&quot;);</span>
        try {
            // yes, this infinite loop can only exit by an exception.  But this is
            // the beating heart of a server, and to the best of my current knowledge,
            // when a server socket is force-closed it's going to throw an exception, and
            // that's just part of its life cycle
            //noinspection InfiniteLoopStatement
            while (true) {
<span class="fc" id="L81">                Socket freshSocket = serverSocket.accept();</span>
                // see takeOffDeque for the code that pulls sockets out of this queue
                // and sends them for processing
<span class="fc" id="L84">                socketQueue.add(freshSocket);</span>
<span class="fc" id="L85">            }</span>
<span class="fc" id="L86">        } catch (IOException ex) {</span>
<span class="fc" id="L87">            handleServerException(ex, logger);</span>
        }
<span class="fc" id="L89">    }</span>

    /**
     * An infinite loop that pulls connected sockets out of the
     * deque for processing
     */
    private void takeOffDequeForProcessing() throws InterruptedException {
<span class="fc" id="L96">        Thread.currentThread().setName(&quot;socket queue handler&quot;);</span>

        // this is a known infinite loop, meant to keep running all during the runtime
        //noinspection InfiniteLoopStatement
        while(true) {
<span class="fc" id="L101">            Socket socket = socketQueue.take();</span>
<span class="fc" id="L102">            es.submit(() -&gt; this.doHttpWork(socket));</span>
<span class="fc" id="L103">        }</span>
    }


    void doHttpWork(Socket freshSocket) {
        // provide a name for this thread for easier debugging
<span class="fc" id="L109">        Thread.currentThread().setName(&quot;SocketWrapper thread for &quot; + freshSocket.getInetAddress().getHostAddress());</span>

        try {
            // prepare the socket for later processing
<span class="fc" id="L113">            ISocketWrapper socketWrapper = new SocketWrapper(freshSocket, this, logger, constants.socketTimeoutMillis, constants.hostName);</span>
<span class="fc" id="L114">            logger.logTrace(() -&gt; String.format(&quot;client connected from %s&quot;, socketWrapper.getRemoteAddrWithPort()));</span>

            // add to a set of wrapped sockets so we can precisely close them all at shutdown
<span class="fc" id="L117">            addToSetOfSws(socketWrapper);</span>

<span class="fc" id="L119">            webFramework.httpProcessing(socketWrapper);</span>
<span class="fc" id="L120">        } catch (Exception ex) {</span>
<span class="fc" id="L121">            logger.logAsyncError(() -&gt; StacktraceUtils.stackTraceToString(ex));</span>
<span class="fc" id="L122">        }</span>
<span class="fc" id="L123">    }</span>

    static void handleServerException(IOException ex, ILogger logger) {
<span class="fc bfc" id="L126" title="All 4 branches covered.">        if (!(ex.getMessage().contains(&quot;Socket closed&quot;) || ex.getMessage().contains(&quot;Socket is closed&quot;))) {</span>
<span class="fc" id="L127">            logger.logAsyncError(() -&gt; StacktraceUtils.stackTraceToString(ex));</span>
        }
<span class="fc" id="L129">    }</span>

    @Override
    public void close() throws IOException {
        // close all the running sockets
<span class="fc" id="L134">        setOfSWs.stopAllServers();</span>
<span class="fc" id="L135">        logger.logTrace(() -&gt; &quot;close called on &quot; + this);</span>
        // close the primary server socket
<span class="fc" id="L137">        serverSocket.close();</span>
<span class="fc" id="L138">    }</span>

    @Override
    public String getHost() {
<span class="fc" id="L142">        return serverSocket.getInetAddress().getHostAddress();</span>
    }

    @Override
    public int getPort() {
<span class="fc" id="L147">        return serverSocket.getLocalPort();</span>
    }

    @Override
    public void removeMyRecord(ISocketWrapper socketWrapper) {
<span class="fc" id="L152">        setOfSWs.remove(socketWrapper);</span>
<span class="fc" id="L153">    }</span>

    @Override
    public void addToSetOfSws(ISocketWrapper sw) {
<span class="fc" id="L157">        this.setOfSWs.add(sw);</span>
<span class="fc" id="L158">    }</span>

    /**
     * Returns the name of this server, which is set
     * when the server is instantiated.
     */
    @Override
    public String toString() {
<span class="fc" id="L166">        return this.serverName;</span>
    }

    @Override
    public Future&lt;?&gt; getCentralLoopFuture() {
<span class="fc" id="L171">        return centralLoopFuture;</span>
    }

    @Override
    public HttpServerType getServerType() {
<span class="fc" id="L176">        return serverType;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>
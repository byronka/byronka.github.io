<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>Headers.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">minum</a> &gt; <a href="index.source.html" class="el_package">com.renomad.minum.web</a> &gt; <span class="el_source">Headers.java</span></div><h1>Headers.java</h1><pre class="source lang-java linenums">package com.renomad.minum.web;

import com.renomad.minum.security.ForbiddenUseException;

import java.io.IOException;
import java.io.InputStream;
import java.util.*;

import static com.renomad.minum.utils.Invariants.mustBeTrue;

/**
 * Details extracted from the headers.  For example,
 * is this a keep-alive connection? what is the content-length,
 * and so on.
 * Here is some detail from &lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_HTTP_header_fields&quot;&gt;Wikipedia&lt;/a&gt; on the subject:
 * &lt;p&gt;
 * HTTP header fields are a list of strings sent and received by both
 * the client program and server on every HTTP request and response. These
 * headers are usually invisible to the end-user and are only processed or
 * logged by the server and client applications. They define how information
 * sent/received through the connection are encoded (as in Content-Encoding),
 * the session verification and identification of the client (as in browser
 * cookies, IP address, user-agent) or their anonymity thereof (VPN or
 * proxy masking, user-agent spoofing), how the server should handle data
 * (as in Do-Not-Track), the age (the time it has resided in a shared cache)
 * of the document being downloaded, amongst others.
 * &lt;/p&gt;
 */
public final class Headers{

<span class="fc" id="L31">    public static final Headers EMPTY = new Headers(List.of());</span>
    private static final int MAX_HEADERS_COUNT = 70;

    /**
     * Each line of the headers is read into this data structure
     */
    private final List&lt;String&gt; headerStrings;
    private final Map&lt;String, List&lt;String&gt;&gt; headersMap;

    public Headers(
            List&lt;String&gt; headerStrings
<span class="fc" id="L42">    ) {</span>
<span class="fc" id="L43">        this.headerStrings = new ArrayList&lt;&gt;(headerStrings);</span>
<span class="fc" id="L44">        this.headersMap = Collections.unmodifiableMap(extractHeadersToMap(headerStrings));</span>
<span class="fc" id="L45">    }</span>

    public List&lt;String&gt; getHeaderStrings() {
<span class="fc" id="L48">        return new ArrayList&lt;&gt;(headerStrings);</span>
    }

    /**
     * Obtain any desired header by looking it up in this map.  All keys
     * are made lowercase.
     */
    static Map&lt;String, List&lt;String&gt;&gt; extractHeadersToMap(List&lt;String&gt; headerStrings) {
<span class="fc" id="L56">        var result = new HashMap&lt;String, List&lt;String&gt;&gt;();</span>
<span class="fc bfc" id="L57" title="All 2 branches covered.">        for (var h : headerStrings) {</span>
<span class="fc" id="L58">            var indexOfFirstColon = h.indexOf(&quot;:&quot;);</span>

            // if the header is malformed, just move on
<span class="fc bfc" id="L61" title="All 2 branches covered.">            if (indexOfFirstColon &lt;= 0) continue;</span>

<span class="fc" id="L63">            String key = h.substring(0, indexOfFirstColon).toLowerCase(Locale.ROOT);</span>
<span class="fc" id="L64">            String value = h.substring(indexOfFirstColon+1).trim();</span>

<span class="fc bfc" id="L66" title="All 2 branches covered.">            if (result.containsKey(key)) {</span>
<span class="fc" id="L67">                var currentValue = result.get(key);</span>
<span class="fc" id="L68">                List&lt;String&gt; newList = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L69">                newList.add(value);</span>
<span class="fc" id="L70">                newList.addAll(currentValue);</span>
<span class="fc" id="L71">                result.put(key, newList);</span>
<span class="fc" id="L72">            } else {</span>
<span class="fc" id="L73">                result.put(key, List.of(value));</span>
            }

<span class="fc" id="L76">        }</span>
<span class="fc" id="L77">        return result;</span>
    }

    /**
     * Gets the one content-type header, or returns an empty string
     */
    public String contentType() {
        // find the header that starts with content-type
<span class="fc" id="L85">        List&lt;String&gt; cts = Objects.requireNonNullElse(headersMap.get(&quot;content-type&quot;), List.of());</span>
<span class="fc bfc" id="L86" title="All 2 branches covered.">        if (cts.size() &gt; 1) {</span>
<span class="fc" id="L87">            cts.sort(Comparator.naturalOrder());</span>
<span class="fc" id="L88">            throw new WebServerException(&quot;The number of content-type headers must be exactly zero or one.  Received: &quot; + cts);</span>
        }
<span class="fc bfc" id="L90" title="All 2 branches covered.">        if (!cts.isEmpty()) {</span>
<span class="fc" id="L91">            return cts.getFirst();</span>
        }

        // if we don't find a content-type header, or if we don't find one we can handle, return an empty string.
<span class="fc" id="L95">        return &quot;&quot;;</span>
    }

    /**
     * Given the list of headers, find the one with the length of the
     * body of the POST and return that value as an integer. If
     * we do not find a content length, return -1.
     */
    public int contentLength() {
<span class="fc" id="L104">        List&lt;String&gt; cl = Objects.requireNonNullElse(headersMap.get(&quot;content-length&quot;), List.of());</span>
<span class="fc bfc" id="L105" title="All 2 branches covered.">        if (cl.size() &gt; 1) {</span>
<span class="fc" id="L106">            cl.sort(Comparator.naturalOrder());</span>
<span class="fc" id="L107">            throw new WebServerException(&quot;The number of content-length headers must be exactly zero or one.  Received: &quot; + cl);</span>
        }
<span class="fc" id="L109">        int contentLength = -1;</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">        if (!cl.isEmpty()) {</span>
<span class="fc" id="L111">            contentLength = Integer.parseInt(cl.getFirst());</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">            mustBeTrue(contentLength &gt;= 0, &quot;Content-length cannot be negative&quot;);</span>
        }

<span class="fc" id="L115">        return contentLength;</span>
    }

    /**
     * Indicates whether the headers in this request
     * have a Connection: Keep-Alive
     */
    public boolean hasKeepAlive() {
<span class="fc" id="L123">        List&lt;String&gt; connectionHeader = headersMap.get(&quot;connection&quot;);</span>
<span class="fc bfc" id="L124" title="All 2 branches covered.">        if (connectionHeader == null) return false;</span>
<span class="fc" id="L125">        return connectionHeader.stream().anyMatch(x -&gt; x.toLowerCase(Locale.ROOT).contains(&quot;keep-alive&quot;));</span>
    }

    /**
     * Indicates whether the headers in this request
     * have a Connection: close
     */
    public boolean hasConnectionClose() {
<span class="fc" id="L133">        List&lt;String&gt; connectionHeader = headersMap.get(&quot;connection&quot;);</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">        if (connectionHeader == null) return false;</span>
<span class="fc" id="L135">        return connectionHeader.stream().anyMatch(x -&gt; x.toLowerCase(Locale.ROOT).contains(&quot;close&quot;));</span>
    }

    /**
     * Loop through the lines of header in the HTTP message
     */
    static List&lt;String&gt; getAllHeaders(InputStream is, IInputStreamUtils inputStreamUtils) {
        // we'll give the list an initial size, since in most cases we're going to have headers.
        // 10 is just an arbitrary number, seems about right.
<span class="fc" id="L144">        List&lt;String&gt; headers = new ArrayList&lt;&gt;(10);</span>
<span class="fc" id="L145">        for (int i = 0;; i++) {</span>
<span class="fc bfc" id="L146" title="All 2 branches covered.">            if (i &gt;=MAX_HEADERS_COUNT) {</span>
<span class="fc" id="L147">                throw new ForbiddenUseException(&quot;User tried sending too many headers.  max: &quot; + MAX_HEADERS_COUNT);</span>
            }
            String value;
            try {
<span class="fc" id="L151">                value = inputStreamUtils.readLine(is);</span>
<span class="fc" id="L152">            } catch (IOException e) {</span>
<span class="fc" id="L153">                throw new WebServerException(e);</span>
<span class="fc" id="L154">            }</span>
<span class="fc bfc" id="L155" title="All 4 branches covered.">            if (value != null &amp;&amp; value.isBlank()) {</span>
<span class="fc" id="L156">                break;</span>
<span class="fc bfc" id="L157" title="All 2 branches covered.">            } else if (value == null) {</span>
<span class="fc" id="L158">                return headers;</span>
            } else {
<span class="fc" id="L160">                headers.add(value);</span>
            }
        }
<span class="fc" id="L163">        return headers;</span>
    }

    /**
     * Allows a user to obtain any header value by its key, case-insensitively
     * @return a {@link List} of string values, or null
     * if no header was found.
     */
    public List&lt;String&gt; valueByKey(String key) {
<span class="fc" id="L172">        return headersMap.get(key.toLowerCase(Locale.ROOT));</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="fc bfc" id="L177" title="All 2 branches covered.">        if (this == o) return true;</span>
<span class="fc bfc" id="L178" title="All 4 branches covered.">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L179">        Headers headers = (Headers) o;</span>
<span class="fc bfc" id="L180" title="All 4 branches covered.">        return Objects.equals(headerStrings, headers.headerStrings) &amp;&amp; Objects.equals(headersMap, headers.headersMap);</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L185">        return Objects.hash(headerStrings, headersMap);</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L190">        return &quot;Headers{&quot; +</span>
                &quot;headerStrings=&quot; + headerStrings +
                '}';
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>
<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>RequestLine.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">minum</a> &gt; <a href="index.source.html" class="el_package">com.renomad.minum.web</a> &gt; <span class="el_source">RequestLine.java</span></div><h1>RequestLine.java</h1><pre class="source lang-java linenums">package com.renomad.minum.web;

import com.renomad.minum.logging.ILogger;
import com.renomad.minum.security.ForbiddenUseException;
import com.renomad.minum.utils.StringUtils;

import java.util.*;

import static com.renomad.minum.utils.Invariants.mustNotBeNull;

/**
 * This class holds data and methods for dealing with the
 * &quot;start line&quot; in an HTTP request.  For example,
 * GET /foo HTTP/1.1
 */
public final class RequestLine {

    private final Method method;
    private final PathDetails pathDetails;
    private final HttpVersion version;
    private final String rawValue;
    private final ILogger logger;
    static final int MAX_QUERY_STRING_KEYS_COUNT = 50;

    /**
     * @param method GET, POST, etc.
     * @param pathDetails See {@link PathDetails}
     * @param version the version of HTTP (1.0 or 1.1) we're receiving
     * @param rawValue the entire raw string of the start line
     */
    public RequestLine(
            Method method,
            PathDetails pathDetails,
            HttpVersion version,
            String rawValue,
            ILogger logger
<span class="fc" id="L37">    ) {</span>
<span class="fc" id="L38">        this.method = method;</span>
<span class="fc" id="L39">        this.pathDetails = pathDetails;</span>
<span class="fc" id="L40">        this.version = version;</span>
<span class="fc" id="L41">        this.rawValue = rawValue;</span>
<span class="fc" id="L42">        this.logger = logger;</span>
<span class="fc" id="L43">    }</span>



<span class="fc" id="L47">    public static final RequestLine EMPTY = new RequestLine(Method.NONE, PathDetails.empty, HttpVersion.NONE, &quot;&quot;, null);</span>

    /**
     * Returns a map of the key-value pairs in the URL,
     * for example in {@code http://foo.com?name=alice} you
     * have a key of name and a value of alice.
     */
    public Map&lt;String, String&gt; queryString() {
<span class="fc bfc" id="L55" title="All 4 branches covered.">        if (pathDetails == null || pathDetails.getQueryString().isEmpty()) {</span>
<span class="fc" id="L56">            return Map.of();</span>
        } else {
<span class="fc" id="L58">            return new HashMap&lt;&gt;(pathDetails.getQueryString());</span>
        }

    }

    /**
     * These are the HTTP methods we handle.
     */
<span class="fc" id="L66">    public enum Method {</span>
<span class="fc" id="L67">        GET,</span>
<span class="fc" id="L68">        POST,</span>
<span class="fc" id="L69">        PUT,</span>
<span class="fc" id="L70">        DELETE,</span>
<span class="fc" id="L71">        TRACE,</span>
<span class="fc" id="L72">        PATCH,</span>
<span class="fc" id="L73">        OPTIONS,</span>
<span class="fc" id="L74">        HEAD,</span>

        /**
         * Represents the null value of Method
         */
<span class="fc" id="L79">        NONE;</span>

        /**
         * Get the correct HTTP method for a string provided by the user
         */
        public static Method getMethod(String userSuppliedMethod) {
            // if the method they gave us is longer than the maximum method
            // we know about, it's invalid, and return NONE.
<span class="fc bfc" id="L87" title="All 2 branches covered.">            if (userSuppliedMethod.length() &gt; 7) {</span>
<span class="fc" id="L88">                return NONE;</span>
            }
            // necessary because we need to potentially convert to lowercase
<span class="fc" id="L91">            var sb = new StringBuilder(userSuppliedMethod.length());</span>

<span class="fc bfc" id="L93" title="All 2 branches covered.">            for (int i = 0; i &lt; userSuppliedMethod.length(); i++) {</span>
<span class="fc" id="L94">                char c = userSuppliedMethod.charAt(i);</span>
<span class="fc bfc" id="L95" title="All 4 branches covered.">                if ((c &gt;= 65 &amp;&amp; c &lt;= 90)) { // characters in methods are pure ascii, no UTF-8 to worry about</span>
<span class="fc" id="L96">                    sb.append(c);</span>
<span class="fc bfc" id="L97" title="All 4 branches covered.">                } else if (c &gt;= 97 &amp;&amp; c &lt;= 122) { // if characters are lower-case, make them upper-case</span>
<span class="fc" id="L98">                    sb.append((char)(c - 32));</span>
                } else {
<span class="fc" id="L100">                    return NONE; // if any of the characters are non-ascii-alphabet, it's invalid, bail.</span>
                }
            }
<span class="fc bfc" id="L103" title="All 9 branches covered.">            return switch (sb.toString()) {</span>
<span class="fc" id="L104">                case &quot;GET&quot; -&gt; GET;</span>
<span class="fc" id="L105">                case &quot;POST&quot; -&gt; POST;</span>
<span class="fc" id="L106">                case &quot;PUT&quot; -&gt; PUT;</span>
<span class="fc" id="L107">                case &quot;DELETE&quot; -&gt; DELETE;</span>
<span class="fc" id="L108">                case &quot;TRACE&quot; -&gt; TRACE;</span>
<span class="fc" id="L109">                case &quot;PATCH&quot; -&gt; PATCH;</span>
<span class="fc" id="L110">                case &quot;OPTIONS&quot; -&gt; OPTIONS;</span>
<span class="fc" id="L111">                case &quot;HEAD&quot; -&gt; HEAD;</span>
<span class="fc" id="L112">                default -&gt; NONE;</span>
            };
        }
    }

    /**
     * Given the string value of a Request Line (like GET /hello HTTP/1.1)
     * validate and extract the values for our use.
     */
    public RequestLine extractRequestLine(String value) {
<span class="fc" id="L122">        mustNotBeNull(value);</span>
<span class="fc bfc" id="L123" title="All 2 branches covered.">        if (value.isEmpty()) {</span>
<span class="fc" id="L124">            return RequestLine.EMPTY;</span>
        }
<span class="fc" id="L126">        RequestLineRawValues rawValues = requestLineTokenizer(value);</span>
<span class="fc bfc" id="L127" title="All 2 branches covered.">        if (rawValues == null) {</span>
<span class="fc" id="L128">            return RequestLine.EMPTY;</span>
        }
        Method myMethod;
<span class="fc" id="L131">        myMethod = Method.getMethod(rawValues.method());</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">        if (myMethod.equals(Method.NONE)) {</span>
<span class="fc" id="L133">            logger.logDebug(() -&gt; &quot;Unable to convert method to enum.  Returning empty request line.  Method value provided: &quot; + rawValues.method());</span>
<span class="fc" id="L134">            return RequestLine.EMPTY;</span>
        }
<span class="fc" id="L136">        PathDetails pd = extractPathDetails(rawValues.path());</span>
<span class="fc" id="L137">        HttpVersion httpVersion = getHttpVersion(rawValues.protocol());</span>
<span class="fc bfc" id="L138" title="All 2 branches covered.">        if (httpVersion.equals(HttpVersion.NONE)) {</span>
<span class="fc" id="L139">            return RequestLine.EMPTY;</span>
        }

<span class="fc" id="L142">        return new RequestLine(myMethod, pd, httpVersion, value, logger);</span>
    }

    /**
     * Split the request line into three parts - a method (e.g. GET), a
     * path (e.g. &quot;/&quot; or &quot;/helloworld/hi/foo?name=hello&quot;) and a protocol,
     * which is typically &quot;HTTP/1.1&quot; but might be &quot;HTTP/1.0&quot; in some cases
     * &lt;br&gt;
     * If we don't find exactly three parts, we will return null, which
     * is interpreted by the calling method to mean we didn't receive a
     * valid request line.
     * @param rawRequestLine the full string of the first line received
     *                       after the socket is connected to the client.
     */
    private RequestLineRawValues requestLineTokenizer(String rawRequestLine) {
<span class="fc" id="L157">        int firstSpace = rawRequestLine.indexOf(' ');</span>
<span class="fc bfc" id="L158" title="All 2 branches covered.">        if (firstSpace == -1) {</span>
<span class="fc" id="L159">            return null;</span>
        }
<span class="fc" id="L161">        int secondSpace = rawRequestLine.indexOf(' ', firstSpace + 1);</span>
<span class="fc bfc" id="L162" title="All 2 branches covered.">        if (secondSpace == -1) {</span>
<span class="fc" id="L163">            return null;</span>
        }
<span class="fc" id="L165">        int thirdSpace = rawRequestLine.indexOf(' ', secondSpace + 1);</span>
<span class="fc bfc" id="L166" title="All 2 branches covered.">        if (thirdSpace != -1) {</span>
<span class="fc" id="L167">            return null;</span>
        }
<span class="fc" id="L169">        String myMethod = rawRequestLine.substring(0, firstSpace);</span>
<span class="fc" id="L170">        String path = rawRequestLine.substring(firstSpace + 1, secondSpace);</span>
<span class="fc" id="L171">        String protocol = rawRequestLine.substring(secondSpace + 1);</span>
<span class="fc" id="L172">        return new RequestLineRawValues(myMethod, path, protocol);</span>
    }

    private PathDetails extractPathDetails(String path) {
        PathDetails pd;
        // the request line will have a forward slash at the beginning of
        // the path.  Remove that here.
<span class="fc" id="L179">        String adjustedPath = path.substring(1);</span>
<span class="fc" id="L180">        int locationOfQueryBegin = adjustedPath.indexOf(&quot;?&quot;);</span>
<span class="fc bfc" id="L181" title="All 2 branches covered.">        if (locationOfQueryBegin &gt;= 0) {</span>
            // in this case, we found a question mark, suggesting that a query string exists
<span class="fc" id="L183">            String rawQueryString = adjustedPath.substring(locationOfQueryBegin + 1);</span>
<span class="fc" id="L184">            String isolatedPath = adjustedPath.substring(0, locationOfQueryBegin);</span>
<span class="fc" id="L185">            Map&lt;String, String&gt; queryString = extractMapFromQueryString(rawQueryString);</span>
<span class="fc" id="L186">            pd = new PathDetails(isolatedPath, rawQueryString, queryString);</span>
<span class="fc" id="L187">        } else {</span>
            // in this case, no question mark was found, thus no query string
<span class="fc" id="L189">            pd = new PathDetails(adjustedPath, null, null);</span>
        }
<span class="fc" id="L191">        return pd;</span>
    }


    /**
     * Given a string containing the combined key-values in
     * a query string (e.g. foo=bar&amp;name=alice), split that
     * into a map of the key to value (e.g. foo to bar, and name to alice)
     */
    Map&lt;String, String&gt; extractMapFromQueryString(String rawQueryString) {
<span class="fc" id="L201">        Map&lt;String, String&gt; queryStrings = new HashMap&lt;&gt;();</span>
<span class="fc" id="L202">        StringTokenizer tokenizer = new StringTokenizer(rawQueryString, &quot;&amp;&quot;);</span>
        // we'll only take less than MAX_QUERY_STRING_KEYS_COUNT
<span class="fc bfc" id="L204" title="All 2 branches covered.">        for (int i = 0; tokenizer.hasMoreTokens(); i++) {</span>
<span class="fc bfc" id="L205" title="All 2 branches covered.">            if (i &gt;= MAX_QUERY_STRING_KEYS_COUNT) throw new ForbiddenUseException(&quot;User tried providing too many query string keys.  max: &quot; + MAX_QUERY_STRING_KEYS_COUNT);</span>
            // this should give us a key and value joined with an equal sign, e.g. foo=bar
<span class="fc" id="L207">            String currentKeyValue = tokenizer.nextToken();</span>
<span class="fc" id="L208">            int equalSignLocation = currentKeyValue.indexOf(&quot;=&quot;);</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">            if (equalSignLocation &lt;= 0) return Map.of();</span>
<span class="fc" id="L210">            String key = currentKeyValue.substring(0, equalSignLocation);</span>
<span class="fc" id="L211">            String myRawValue = currentKeyValue.substring(equalSignLocation + 1);</span>
            try {
<span class="fc" id="L213">                String value = StringUtils.decode(myRawValue);</span>
<span class="fc" id="L214">                queryStrings.put(key, value);</span>
<span class="fc" id="L215">            } catch (IllegalArgumentException ex) {</span>
<span class="fc" id="L216">                logger.logDebug(() -&gt; &quot;Query string parsing failed for key: (%s) value: (%s).  Skipping to next key-value pair. error message: %s&quot;.formatted(key, myRawValue, ex.getMessage()));</span>
<span class="fc" id="L217">            }</span>
        }
<span class="fc" id="L219">        return queryStrings;</span>
    }

    /**
     * Extract the HTTP version from the start line
     */
    private HttpVersion getHttpVersion(String version) {
<span class="fc bfc" id="L226" title="All 2 branches covered.">        if (version.equals(&quot;HTTP/1.1&quot;)) {</span>
<span class="fc" id="L227">            return HttpVersion.ONE_DOT_ONE;</span>
<span class="fc bfc" id="L228" title="All 2 branches covered.">        } else if (version.equals(&quot;HTTP/1.0&quot;)) {</span>
<span class="fc" id="L229">            return HttpVersion.ONE_DOT_ZERO;</span>
        } else {
<span class="fc" id="L231">            return HttpVersion.NONE;</span>
        }
    }

    /**
     * Return the method of this request-line.  For example, GET, PUT, POST...
     */
    public Method getMethod() {
<span class="fc" id="L239">        return method;</span>
    }

    /**
     * This returns an object which contains essential information about the path
     * in the request line.  For example, if the request line is &quot;GET /sample?foo=bar HTTP/1.1&quot;,
     * this would hold data for the path (&quot;sample&quot;) and the query string (&quot;foo=bar&quot;)
     */
    public PathDetails getPathDetails() {
<span class="fc" id="L248">        return pathDetails;</span>
    }

    /**
     * Gets the HTTP version, either 1.0 or 1.1
     */
    public HttpVersion getVersion() {
<span class="fc" id="L255">        return this.version;</span>
    }

    /**
     * Get the string value of this request line, such as &quot;GET /sample.html HTTP/1.1&quot;
     */
    public String getRawValue() {
<span class="fc" id="L262">        return rawValue;</span>
    }

    @Override
    public boolean equals(Object o) {
<span class="fc bfc" id="L267" title="All 2 branches covered.">        if (this == o) return true;</span>
<span class="fc bfc" id="L268" title="All 4 branches covered.">        if (o == null || getClass() != o.getClass()) return false;</span>
<span class="fc" id="L269">        RequestLine that = (RequestLine) o;</span>
<span class="fc bfc" id="L270" title="All 10 branches covered.">        return method == that.method &amp;&amp; Objects.equals(pathDetails, that.pathDetails) &amp;&amp; version == that.version &amp;&amp; Objects.equals(rawValue, that.rawValue) &amp;&amp; Objects.equals(logger, that.logger);</span>
    }

    @Override
    public int hashCode() {
<span class="fc" id="L275">        return Objects.hash(method, pathDetails, version, rawValue, logger);</span>
    }

    @Override
    public String toString() {
<span class="fc" id="L280">        return &quot;RequestLine{&quot; +</span>
                &quot;method=&quot; + method +
                &quot;, pathDetails=&quot; + pathDetails +
                &quot;, version=&quot; + version +
                &quot;, rawValue='&quot; + rawValue + '\'' +
                &quot;, logger=&quot; + logger +
                '}';
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>
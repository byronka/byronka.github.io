<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WebFramework.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">minum</a> &gt; <a href="index.source.html" class="el_package">com.renomad.minum.web</a> &gt; <span class="el_source">WebFramework.java</span></div><h1>WebFramework.java</h1><pre class="source lang-java linenums">package com.renomad.minum.web;

import com.renomad.minum.logging.ILogger;
import com.renomad.minum.security.ForbiddenUseException;
import com.renomad.minum.security.ITheBrig;
import com.renomad.minum.security.UnderInvestigation;
import com.renomad.minum.state.Constants;
import com.renomad.minum.state.Context;
import com.renomad.minum.utils.*;

import java.io.IOException;
import java.net.SocketException;
import java.net.SocketTimeoutException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;

import static com.renomad.minum.utils.FileUtils.checkFileIsWithinDirectory;
import static com.renomad.minum.utils.FileUtils.checkForBadFilePatterns;
import static com.renomad.minum.web.StatusLine.StatusCode.*;
import static com.renomad.minum.web.WebEngine.HTTP_CRLF;

/**
 * This class is responsible for the HTTP handling after socket connection.
 * &lt;p&gt;
 *     The public methods are for registering endpoints - code that will be
 *     run for a given combination of HTTP method and path.  See documentation
 *     for the methods in this class.
 * &lt;/p&gt;
 */
public final class WebFramework {

    private final Constants constants;
    private final UnderInvestigation underInvestigation;
    private final IInputStreamUtils inputStreamUtils;
    private final IBodyProcessor bodyProcessor;
    /**
     * This is a variable storing a pseudo-random (non-secure) number
     * that is shown to users when a serious error occurs, which
     * will also be put in the logs, to make finding it easier.
     */
    private final Random randomErrorCorrelationId;
    private final RequestLine emptyRequestLine;
    private final RequestLine validRequestLine;
    private final ITheBrig theBrig;

    public Map&lt;String,String&gt; getSuffixToMimeMappings() {
<span class="fc" id="L52">        return new HashMap&lt;&gt;(fileSuffixToMime);</span>
    }

    /**
     * This is used as a key when registering endpoints
     */
<span class="fc" id="L58">    record MethodPath(RequestLine.Method method, String path) { }</span>

    /**
     * The list of paths that our system is registered to handle.
     */
    private final Map&lt;MethodPath, ThrowingFunction&lt;IRequest, IResponse&gt;&gt; registeredDynamicPaths;

    /**
     * These are registrations for paths that partially match, for example,
     * if the client sends us GET /.well-known/acme-challenge/HGr8U1IeTW4kY_Z6UIyaakzOkyQgPr_7ArlLgtZE8SX
     * and we want to match &quot;.well-known/acme-challenge&quot;
     */
    private final Map&lt;MethodPath, ThrowingFunction&lt;IRequest, IResponse&gt;&gt; registeredPartialPaths;

    /**
     * A function that will be run instead of the ordinary business code. Has
     * provisions for running the business code as well.  See {@link #registerPreHandler(ThrowingFunction)}
     */
    private ThrowingFunction&lt;PreHandlerInputs, IResponse&gt; preHandler;

    /**
     * A function run after the ordinary business code
     */
    private ThrowingFunction&lt;LastMinuteHandlerInputs, IResponse&gt; lastMinuteHandler;

    private final IFileReader fileReader;
    private final Map&lt;String, String&gt; fileSuffixToMime;

    // This is just used for testing.  If it's null, we use the real time.
    private final ZonedDateTime overrideForDateTime;
    private final FullSystem fs;
    private final ILogger logger;

    /**
     * This is the minimum number of bytes in a text response to apply gzip.
     */
    private static final int MINIMUM_NUMBER_OF_BYTES_TO_COMPRESS = 2048;

    void httpProcessing(ISocketWrapper sw) throws Exception {
<span class="fc" id="L97">        try (sw) {</span>
<span class="fc" id="L98">            dumpIfAttacker(sw, fs);</span>
<span class="fc" id="L99">            final var is = sw.getInputStream();</span>

            // By default, browsers expect the server to run in keep-alive mode.
            // We'll break out later if we find that the browser doesn't do keep-alive
            while (true) {
<span class="fc" id="L104">                final String rawStartLine = inputStreamUtils.readLine(is);</span>
<span class="fc" id="L105">                long startMillis = System.currentTimeMillis();</span>
<span class="fc bfc" id="L106" title="All 4 branches covered.">                if (rawStartLine == null || rawStartLine.isEmpty()) {</span>
                    // here, the client connected, sent nothing, and closed.
                    // nothing to do but return.
<span class="fc" id="L109">                    logger.logTrace(() -&gt; &quot;rawStartLine was empty.  Returning.&quot;);</span>
<span class="fc" id="L110">                    break;</span>
                }
<span class="fc" id="L112">                final RequestLine requestLine = getProcessedRequestLine(sw, rawStartLine);</span>

<span class="fc bfc" id="L114" title="All 2 branches covered.">                if (requestLine.equals(emptyRequestLine)) {</span>
                    // here, the client sent something we cannot parse.
                    // nothing to do but return.
<span class="fc" id="L117">                    logger.logTrace(() -&gt; &quot;RequestLine was unparseable.  Returning.&quot;);</span>
<span class="fc" id="L118">                    break;</span>
                }
                // check if the user is seeming to attack us.
<span class="fc" id="L121">                checkIfSuspiciousPath(sw, requestLine);</span>

                // React to what the user requested, generate a result
<span class="fc" id="L124">                Headers headers = getHeaders(sw);</span>
<span class="fc" id="L125">                boolean isKeepAlive = determineIfKeepAlive(requestLine, headers, logger);</span>
<span class="fc" id="L126">                IRequest request = new Request(headers, requestLine, sw.getRemoteAddr(), sw, bodyProcessor);</span>
<span class="fc" id="L127">                IResponse response = processRequest(request, sw, requestLine, headers);</span>

                // check that the response is non-null.  If it is null, that suggests
                // the developer made a mistake.
<span class="fc bfc" id="L131" title="All 2 branches covered.">                if (response == null) {</span>
<span class="fc" id="L132">                    throw new WebServerException(&quot;The returned value for the endpoint \&quot;%s\&quot; was null.&quot;.formatted(request.getRequestLine().getPathDetails().getIsolatedPath()));</span>
                }

                // calculate proper headers for the response
<span class="fc" id="L136">                StringBuilder headerStringBuilder = addDefaultHeaders(response);</span>
<span class="fc" id="L137">                addOptionalExtraHeaders(response, headerStringBuilder);</span>
<span class="fc" id="L138">                addKeepAliveTimeout(isKeepAlive, headerStringBuilder);</span>

                // inspect the response being sent, see whether we can compress the data.
<span class="fc" id="L141">                IResponse adjustedResponse = potentiallyCompress(request.getHeaders(), response, headerStringBuilder);</span>
<span class="fc" id="L142">                applyContentLength(headerStringBuilder, adjustedResponse.getBodyLength());</span>
<span class="fc" id="L143">                confirmBodyHasContentType(request, response);</span>

                // send the headers
<span class="fc" id="L146">                sw.send(headerStringBuilder.append(HTTP_CRLF).toString().getBytes(StandardCharsets.US_ASCII));</span>

                // if the user sent a HEAD request, we send everything back except the body.
                // even though we skip the body, this requires full processing to get the
                // numbers right, like content-length.
<span class="fc bfc" id="L151" title="All 2 branches covered.">                if (request.getRequestLine().getMethod().equals(RequestLine.Method.HEAD)) {</span>
<span class="fc" id="L152">                    logger.logDebug(() -&gt; &quot;client &quot; + request.getRemoteRequester() +</span>
<span class="fc" id="L153">                            &quot; is requesting HEAD for &quot; + request.getRequestLine().getPathDetails().getIsolatedPath() +</span>
                            &quot;.  Excluding body from response&quot;);
                } else {
                    // send the body
<span class="fc" id="L157">                    adjustedResponse.sendBody(sw);</span>
                }

<span class="fc" id="L160">                sw.flush();</span>

                // print how long this processing took
<span class="fc" id="L163">                long endMillis = System.currentTimeMillis();</span>
<span class="fc" id="L164">                logger.logTrace(() -&gt; String.format(&quot;full processing (including communication time) of %s %s took %d millis&quot;, sw, requestLine, endMillis - startMillis));</span>
<span class="fc bfc" id="L165" title="All 2 branches covered.">                if (!isKeepAlive) break;</span>
<span class="fc" id="L166">            }</span>
<span class="fc" id="L167">        } catch (SocketException | SocketTimeoutException ex) {</span>
<span class="fc" id="L168">            handleReadTimedOut(sw, ex, logger);</span>
<span class="fc" id="L169">        } catch (ForbiddenUseException ex) {</span>
<span class="fc" id="L170">            handleForbiddenUse(sw, ex, logger, theBrig, constants.vulnSeekingJailDuration);</span>
<span class="fc" id="L171">        } catch (IOException ex) {</span>
<span class="fc" id="L172">            handleIOException(sw, ex, logger, theBrig, underInvestigation, constants.vulnSeekingJailDuration);</span>
<span class="fc" id="L173">        }</span>
<span class="fc" id="L174">    }</span>


    static void handleIOException(ISocketWrapper sw, IOException ex, ILogger logger, ITheBrig theBrig, UnderInvestigation underInvestigation, int vulnSeekingJailDuration ) {
<span class="fc" id="L178">        logger.logDebug(() -&gt; ex.getMessage() + &quot; (at Server.start)&quot;);</span>
<span class="fc" id="L179">        String suspiciousClues = underInvestigation.isClientLookingForVulnerabilities(ex.getMessage());</span>

<span class="fc bfc" id="L181" title="All 4 branches covered.">        if (!suspiciousClues.isEmpty() &amp;&amp; theBrig != null) {</span>
<span class="fc" id="L182">            logger.logDebug(() -&gt; sw.getRemoteAddr() + &quot; is looking for vulnerabilities, for this: &quot; + suspiciousClues);</span>
<span class="fc" id="L183">            theBrig.sendToJail(sw.getRemoteAddr() + &quot;_vuln_seeking&quot;, vulnSeekingJailDuration);</span>
        }
<span class="fc" id="L185">    }</span>

    static void handleForbiddenUse(ISocketWrapper sw, ForbiddenUseException ex, ILogger logger, ITheBrig theBrig, int vulnSeekingJailDuration) {
<span class="fc" id="L188">        logger.logDebug(() -&gt; sw.getRemoteAddr() + &quot; is looking for vulnerabilities, for this: &quot; + ex.getMessage());</span>
<span class="fc bfc" id="L189" title="All 2 branches covered.">        if (theBrig != null) {</span>
<span class="fc" id="L190">            theBrig.sendToJail(sw.getRemoteAddr() + &quot;_vuln_seeking&quot;, vulnSeekingJailDuration);</span>
        } else {
<span class="fc" id="L192">            logger.logDebug(() -&gt; &quot;theBrig is null at handleForbiddenUse, will not store address in database&quot;);</span>
        }
<span class="fc" id="L194">    }</span>

    static void handleReadTimedOut(ISocketWrapper sw, IOException ex, ILogger logger) {
        /*
        if we close the application on the server side, there's a good
        likelihood a SocketException will come bubbling through here.
        NOTE:
          it seems that Socket closed is what we get when the client closes the connection in non-SSL, and conversely,
          if we are operating in secure (i.e. SSL/TLS) mode, we get &quot;an established connection...&quot;
        */
<span class="fc bfc" id="L204" title="All 2 branches covered.">        if (ex.getMessage().equals(&quot;Read timed out&quot;)) {</span>
<span class="fc" id="L205">            logger.logTrace(() -&gt; &quot;Read timed out - remote address: &quot; + sw.getRemoteAddrWithPort());</span>
        } else {
<span class="fc" id="L207">            logger.logDebug(() -&gt; ex.getMessage() + &quot; - remote address: &quot; + sw.getRemoteAddrWithPort());</span>
        }
<span class="fc" id="L209">    }</span>

    /**
     * Logic for how to process an incoming request.  For example, did the developer
     * write a function to handle this? Is it a request for a static file, like an image
     * or script?  Did the user provide a &quot;pre&quot; or &quot;post&quot; handler?
     */
    IResponse processRequest(
            IRequest clientRequest,
            ISocketWrapper sw,
            RequestLine requestLine,
            Headers requestHeaders) throws Exception {
        IResponse response;
<span class="fc" id="L222">        ThrowingFunction&lt;IRequest, IResponse&gt; endpoint = findEndpointForThisStartline(requestLine, requestHeaders);</span>
<span class="fc bfc" id="L223" title="All 2 branches covered.">        if (endpoint == null) {</span>
<span class="fc" id="L224">            response = Response.buildLeanResponse(CODE_404_NOT_FOUND);</span>
        } else {
<span class="fc" id="L226">            long millisAtStart = System.currentTimeMillis();</span>
            try {
<span class="fc bfc" id="L228" title="All 2 branches covered.">                if (preHandler != null) {</span>
<span class="fc" id="L229">                    response = preHandler.apply(new PreHandlerInputs(clientRequest, endpoint, sw));</span>
                } else {
<span class="fc" id="L231">                    response = endpoint.apply(clientRequest);</span>
                }
<span class="fc" id="L233">            } catch (Exception ex) {</span>
                // if an error happens while running an endpoint's code, this is the
                // last-chance handling of that error where we return a 500 and a
                // random code to the client, so a developer can find the detailed
                // information in the logs, which have that same value.
<span class="fc" id="L238">                int randomNumber = randomErrorCorrelationId.nextInt();</span>
<span class="fc" id="L239">                logger.logAsyncError(() -&gt; &quot;error while running endpoint &quot; + endpoint + &quot;. Code: &quot; + randomNumber + &quot;. Error: &quot; + StacktraceUtils.stackTraceToString(ex));</span>
<span class="fc" id="L240">                response = Response.buildResponse(CODE_500_INTERNAL_SERVER_ERROR, Map.of(&quot;Content-Type&quot;, &quot;text/plain;charset=UTF-8&quot;), &quot;Server error: &quot; + randomNumber);</span>
<span class="fc" id="L241">            }</span>
<span class="fc" id="L242">            long millisAtEnd = System.currentTimeMillis();</span>
<span class="fc" id="L243">            logger.logTrace(() -&gt; String.format(&quot;handler processing of %s %s took %d millis&quot;, sw, requestLine, millisAtEnd - millisAtStart));</span>
        }

        // if the user has chosen to customize the response based on status code, that will
        // be applied now, and it will override the previous response.
<span class="fc bfc" id="L248" title="All 2 branches covered.">        if (lastMinuteHandler != null) {</span>
<span class="fc" id="L249">            response = lastMinuteHandler.apply(new LastMinuteHandlerInputs(clientRequest, response));</span>
        }

<span class="fc" id="L252">        return response;</span>
    }

    private Headers getHeaders(ISocketWrapper sw) {
    /*
       next we will read the headers (e.g. Content-Type: foo/bar) one-by-one.

       the headers tell us vital information about the
       body.  If, for example, we're getting a POST and receiving a
       www form url encoded, there will be a header of &quot;content-length&quot;
       that will mention how many bytes to read.  On the other hand, if
       we're receiving a multipart, there will be no content-length, but
       the content-type will include the boundary string.
    */
<span class="fc" id="L266">        List&lt;String&gt; allHeaders = Headers.getAllHeaders(sw.getInputStream(), inputStreamUtils);</span>
<span class="fc" id="L267">        Headers hi = new Headers(allHeaders);</span>
<span class="fc" id="L268">        logger.logTrace(() -&gt; &quot;The headers are: &quot; + hi.getHeaderStrings());</span>
<span class="fc" id="L269">        return hi;</span>
    }

    /**
     * determine if we are in a keep-alive connection
     */
    static boolean determineIfKeepAlive(RequestLine sl, Headers hi, ILogger logger) {
<span class="fc" id="L276">        boolean isKeepAlive = false;</span>
<span class="fc bfc" id="L277" title="All 2 branches covered.">        if (sl.getVersion() == HttpVersion.ONE_DOT_ZERO) {</span>
<span class="fc" id="L278">            isKeepAlive = hi.hasKeepAlive();</span>
<span class="fc bfc" id="L279" title="All 2 branches covered.">        } else if (sl.getVersion() == HttpVersion.ONE_DOT_ONE) {</span>
<span class="fc bfc" id="L280" title="All 2 branches covered.">            isKeepAlive = ! hi.hasConnectionClose();</span>
        }
<span class="fc" id="L282">        boolean finalIsKeepAlive = isKeepAlive;</span>
<span class="fc" id="L283">        logger.logTrace(() -&gt; &quot;Is this a keep-alive connection? &quot; + finalIsKeepAlive);</span>
<span class="fc" id="L284">        return isKeepAlive;</span>
    }

    RequestLine getProcessedRequestLine(ISocketWrapper sw, String rawStartLine) {
<span class="fc" id="L288">        logger.logTrace(() -&gt; sw + &quot;: raw request line received: &quot; + rawStartLine);</span>

<span class="fc" id="L290">        RequestLine extractedRequestLine = validRequestLine.extractRequestLine(rawStartLine);</span>
<span class="fc" id="L291">        logger.logTrace(() -&gt; sw + &quot;: RequestLine has been derived: &quot; + extractedRequestLine);</span>
<span class="fc" id="L292">        return extractedRequestLine;</span>
    }

    void checkIfSuspiciousPath(ISocketWrapper sw, RequestLine requestLine) {
<span class="fc" id="L296">        String suspiciousClues = underInvestigation.isLookingForSuspiciousPaths(</span>
<span class="fc" id="L297">                requestLine.getPathDetails().getIsolatedPath());</span>
<span class="fc bfc" id="L298" title="All 2 branches covered.">        if (!suspiciousClues.isEmpty()) {</span>
<span class="fc" id="L299">            String msg = sw.getRemoteAddr() + &quot; is looking for a vulnerability, for this: &quot; + suspiciousClues;</span>
<span class="fc" id="L300">            throw new ForbiddenUseException(msg);</span>
        }
<span class="fc" id="L302">    }</span>

    /**
     * Drops the connection immediately if the client is recognized
     * as someone we consider an attacker, by dint of having been
     * added to a blacklist in {@link com.renomad.minum.security.TheBrig}.
     */
    boolean dumpIfAttacker(ISocketWrapper sw, FullSystem fs) {
<span class="fc bfc" id="L310" title="All 2 branches covered.">        if (fs == null) {</span>
<span class="fc" id="L311">            return false;</span>
<span class="fc bfc" id="L312" title="All 2 branches covered.">        } else if (fs.getTheBrig() == null) {</span>
<span class="fc" id="L313">            return false;</span>
        } else {
<span class="fc" id="L315">            dumpIfAttacker(sw, fs.getTheBrig());</span>
<span class="fc" id="L316">            return true;</span>
        }
    }

    void dumpIfAttacker(ISocketWrapper sw, ITheBrig theBrig) {
<span class="fc" id="L321">        String remoteClient = sw.getRemoteAddr();</span>
<span class="fc bfc" id="L322" title="All 2 branches covered.">        if (theBrig.isInJail(remoteClient + &quot;_vuln_seeking&quot;)) {</span>
            // if this client is a vulnerability seeker, throw an exception,
            // causing them to get dumped unceremoniously
<span class="fc" id="L325">            String message = &quot;closing the socket on &quot; + remoteClient + &quot; due to being found in the brig&quot;;</span>
<span class="fc" id="L326">            logger.logDebug(() -&gt; message);</span>
<span class="fc" id="L327">            throw new ForbiddenUseException(message);</span>
        }
<span class="fc" id="L329">    }</span>

    /**
     * Prepare some of the basic server response headers, like the status code, the
     * date-time stamp, the server name.
     */
    private StringBuilder addDefaultHeaders(IResponse response) {

<span class="fc" id="L337">        String date = Objects.requireNonNullElseGet(overrideForDateTime, () -&gt; ZonedDateTime.now(ZoneId.of(&quot;UTC&quot;))).format(DateTimeFormatter.RFC_1123_DATE_TIME);</span>

        // we'll store the status line and headers in this
<span class="fc" id="L340">        StringBuilder headerStringBuilder = new StringBuilder(600); // 600 is just a magic arbitrary number I picked, because our response headers</span>
                                                                    // are not usually too large - even if the user added a bunch, there is a good
                                                                    // chance it would be far under 600.  If that turns out to be wrong, adjust/redesign

        // add the status line
<span class="fc" id="L345">        headerStringBuilder.append(&quot;HTTP/1.1 &quot;).append(response.getStatusCode().code).append(&quot; &quot;).append(response.getStatusCode().shortDescription).append(HTTP_CRLF);</span>

        // add a date-timestamp
<span class="fc" id="L348">        headerStringBuilder.append(&quot;Date: &quot;).append(date).append(HTTP_CRLF);</span>

        // add the server name
<span class="fc" id="L351">        headerStringBuilder.append(&quot;Server: minum&quot;).append(HTTP_CRLF);</span>

<span class="fc" id="L353">        return headerStringBuilder;</span>
    }

    /**
     * Add extra headers specified by the business logic (set by the developer)
     */
    private static void addOptionalExtraHeaders(IResponse response, StringBuilder stringBuilder) {
<span class="fc bfc" id="L360" title="All 2 branches covered.">        for (Map.Entry&lt;String,String&gt; header : response.getExtraHeaders().entrySet()) {</span>
<span class="fc" id="L361">            stringBuilder.append(header.getKey())</span>
<span class="fc" id="L362">                    .append(&quot;: &quot;)</span>
<span class="fc" id="L363">                    .append(header.getValue())</span>
<span class="fc" id="L364">                    .append(HTTP_CRLF);</span>
<span class="fc" id="L365">        }</span>
<span class="fc" id="L366">    }</span>

    /**
     * If a response body exists, it needs to have a content-type specified,
     * or throw an exception. Otherwise, the user could totally miss they did
     * not set a content-type, because the browser will inspect the data and
     * do sort-of-the-right-thing a lot of the time, but we want to enforce correctness.
     */
    static void confirmBodyHasContentType(IRequest request, IResponse response) {
        // check the correctness of the content-type header versus the data length (if any data, that is)
<span class="fc" id="L376">        boolean hasContentType = response.getExtraHeaders().keySet().stream().anyMatch(x -&gt; x.toLowerCase(Locale.ROOT).equals(&quot;content-type&quot;));</span>

        // if there *is* data, we had better be returning a content type
<span class="fc bfc" id="L379" title="All 4 branches covered.">        if (response.getBodyLength() &gt; 0 &amp;&amp; !hasContentType) {</span>
<span class="fc" id="L380">            throw new WebServerException(&quot;a Content-Type header must be specified in the Response object if it returns data. Response details: &quot; + response + &quot; Request: &quot; + request);</span>
        }
<span class="fc" id="L382">    }</span>

    /**
     * If this is a keep-alive communication, add a header specifying the
     * socket timeout for the browser.
     */
    private void addKeepAliveTimeout(boolean isKeepAlive, StringBuilder stringBuilder) {
        // if we're a keep-alive connection, reply with a keep-alive header
<span class="fc bfc" id="L390" title="All 2 branches covered.">        if (isKeepAlive) {</span>
<span class="fc" id="L391">            stringBuilder.append(&quot;Keep-Alive: timeout=&quot;).append(constants.keepAliveTimeoutSeconds).append(HTTP_CRLF);</span>
        }
<span class="fc" id="L393">    }</span>

    /**
     * The rules regarding the content-length header are byzantine.  Even in the cases
     * where you aren't returning anything, servers can use this header to determine when the
     * response is finished.
     * See &lt;a href=&quot;https://www.rfc-editor.org/rfc/rfc9110.html#name-content-length&quot;&gt;Content-Length in the HTTP spec&lt;/a&gt;
     */
    private static void applyContentLength(StringBuilder stringBuilder, long bodyLength) {
<span class="fc" id="L402">        stringBuilder.append(&quot;Content-Length: &quot;).append(bodyLength).append(HTTP_CRLF);</span>
<span class="fc" id="L403">    }</span>

    /**
     * This method will examine the request headers and response content-type, and
     * compress the outgoing data if necessary.
     */
    static IResponse potentiallyCompress(Headers requestHeaders, IResponse response, StringBuilder headerStringBuilder) throws IOException {
        // we may make modifications to the response body at this point, specifically
        // we may compress the data, if the client requested it.
        // see https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Accept-encoding
<span class="fc" id="L413">        List&lt;String&gt; acceptEncoding = requestHeaders.valueByKey(&quot;accept-encoding&quot;);</span>

<span class="fc bfc" id="L415" title="All 2 branches covered.">        if (response.isBodyText()) {</span>
<span class="fc" id="L416">            return compressBodyIfRequested(response, acceptEncoding, headerStringBuilder, MINIMUM_NUMBER_OF_BYTES_TO_COMPRESS);</span>
        }
<span class="fc" id="L418">        return response;</span>
    }

    /**
     * This method will examine the content-encoding headers, and if &quot;gzip&quot; is
     * requested by the client, we will replace the body bytes with compressed
     * bytes, using the GZIP compression algorithm, as long as the response body
     * is greater than minNumberBytes bytes.
     *
     * @param acceptEncoding headers sent by the client about what compression
     *                       algorithms will be understood.
     * @param stringBuilder  the string we are gradually building up to send back to
     *                       the client for the status line and headers. We'll use it
     *                       here if we need to append a content-encoding - that is,
     *                       if we successfully compress data as gzip.
     * @param minNumberBytes number of bytes must be larger than this to compress.
     */
    static IResponse compressBodyIfRequested(IResponse response, List&lt;String&gt; acceptEncoding, StringBuilder stringBuilder, int minNumberBytes) throws IOException {
<span class="fc bfc" id="L436" title="All 2 branches covered.">        String allContentEncodingHeaders = acceptEncoding != null ? String.join(&quot;;&quot;, acceptEncoding) : &quot;&quot;;</span>
<span class="fc bfc" id="L437" title="All 4 branches covered.">        if (response.getBodyLength() &gt;= minNumberBytes &amp;&amp; allContentEncodingHeaders.contains(&quot;gzip&quot;)) {</span>
<span class="fc" id="L438">            stringBuilder.append(&quot;Content-Encoding: gzip&quot;).append(HTTP_CRLF);</span>
<span class="fc" id="L439">            stringBuilder.append(&quot;Vary: accept-encoding&quot;).append(HTTP_CRLF);</span>
<span class="fc" id="L440">            return ((Response)response).compressBody();</span>
        }
<span class="fc" id="L442">        return response;</span>
    }

    /**
     * Looks through the mappings of {@link MethodPath} and path to registered endpoints
     * or the static cache and returns the appropriate one (If we
     * do not find anything, return null)
     */
    ThrowingFunction&lt;IRequest, IResponse&gt; findEndpointForThisStartline(RequestLine sl, Headers requestHeaders) {
        ThrowingFunction&lt;IRequest, IResponse&gt; handler;
<span class="fc" id="L452">        logger.logTrace(() -&gt; &quot;Seeking a handler for &quot; + sl);</span>

        // first we check if there's a simple direct match
<span class="fc" id="L455">        String requestedPath = sl.getPathDetails().getIsolatedPath().toLowerCase(Locale.ROOT);</span>

        // if the user is asking for a HEAD request, they want to run a GET command
        // but don't want the body.  We'll simply exclude sending the body, later on, when returning the data
<span class="fc bfc" id="L459" title="All 2 branches covered.">        RequestLine.Method method = sl.getMethod() == RequestLine.Method.HEAD ? RequestLine.Method.GET : sl.getMethod();</span>

<span class="fc" id="L461">        MethodPath key = new MethodPath(method, requestedPath);</span>
<span class="fc" id="L462">        handler = registeredDynamicPaths.get(key);</span>

<span class="fc bfc" id="L464" title="All 2 branches covered.">        if (handler == null) {</span>
<span class="fc" id="L465">            logger.logTrace(() -&gt; &quot;No direct handler found.  looking for a partial match for &quot; + requestedPath);</span>
<span class="fc" id="L466">            handler = findHandlerByPartialMatch(sl);</span>
        }

<span class="fc bfc" id="L469" title="All 2 branches covered.">        if (handler == null) {</span>
<span class="fc" id="L470">            logger.logTrace(() -&gt; &quot;No partial match found, checking files on disk for &quot; + requestedPath );</span>
<span class="fc" id="L471">            handler = findHandlerByFilesOnDisk(sl, requestHeaders);</span>
        }

        // we'll return this, and it could be a null.
<span class="fc" id="L475">        return handler;</span>
    }

    /**
     * last ditch effort - look on disk.  This response will either
     * be the file to return, or null if we didn't find anything.
     */
    private ThrowingFunction&lt;IRequest, IResponse&gt; findHandlerByFilesOnDisk(RequestLine sl, Headers requestHeaders) {
<span class="fc bfc" id="L483" title="All 4 branches covered.">        if (sl.getMethod() != RequestLine.Method.GET &amp;&amp; sl.getMethod() != RequestLine.Method.HEAD) {</span>
<span class="fc" id="L484">            return null;</span>
        }
<span class="fc" id="L486">        String requestedPath = sl.getPathDetails().getIsolatedPath();</span>
<span class="fc" id="L487">        IResponse response = readStaticFile(requestedPath, requestHeaders);</span>
<span class="fc" id="L488">        return request -&gt; response;</span>
    }


    /**
     * Get a file from a path and create a response for it with a mime type.
     * &lt;p&gt;
     *     Parent directories are made unavailable by searching the path for
     *     bad characters. see {@link FileUtils#checkForBadFilePatterns}
     * &lt;/p&gt;
     *
     * @return a response with the file contents and caching headers and mime if valid.
     *  if the path has invalid characters, we'll return a &quot;bad request&quot; response.
     */
    IResponse readStaticFile(String path, Headers requestHeaders) {
        try {
<span class="fc" id="L504">            checkForBadFilePatterns(path);</span>
<span class="fc" id="L505">        } catch (Exception ex) {</span>
<span class="fc" id="L506">            logger.logDebug(() -&gt; String.format(&quot;Bad path requested at readStaticFile: %s.  Exception: %s&quot;, path, ex.getMessage()));</span>
<span class="fc" id="L507">            return Response.buildLeanResponse(CODE_400_BAD_REQUEST);</span>
<span class="fc" id="L508">        }</span>
<span class="fc" id="L509">        String mimeType = null;</span>

        try {
<span class="fc" id="L512">            checkFileIsWithinDirectory(path, constants.staticFilesDirectory);</span>
<span class="fc" id="L513">        } catch (Exception ex) {</span>
<span class="fc" id="L514">            logger.logDebug(() -&gt; String.format(&quot;Unable to find %s in allowed directories&quot;, path));</span>
<span class="fc" id="L515">            return Response.buildLeanResponse(CODE_404_NOT_FOUND);</span>
<span class="fc" id="L516">        }</span>

        try {
<span class="fc" id="L519">            Path staticFilePath = Path.of(constants.staticFilesDirectory).resolve(path);</span>
<span class="fc bfc" id="L520" title="All 2 branches covered.">            if (!Files.isRegularFile(staticFilePath)) {</span>
<span class="fc" id="L521">                logger.logDebug(() -&gt; String.format(&quot;No readable regular file found at %s&quot;, path));</span>
<span class="fc" id="L522">                return Response.buildLeanResponse(CODE_404_NOT_FOUND);</span>
            }

            // if the provided path has a dot in it, use that
            // to obtain a suffix for determining file type
<span class="fc" id="L527">            int suffixBeginIndex = path.lastIndexOf('.');</span>
<span class="fc bfc" id="L528" title="All 2 branches covered.">            if (suffixBeginIndex &gt; 0) {</span>
<span class="fc" id="L529">                String suffix = path.substring(suffixBeginIndex+1);</span>
<span class="fc" id="L530">                mimeType = fileSuffixToMime.get(suffix);</span>
            }

            // if we don't find any registered mime types for this
            // suffix, or if it doesn't have a suffix, set the mime type
            // to application/octet-stream
<span class="fc bfc" id="L536" title="All 2 branches covered.">            if (mimeType == null) {</span>
<span class="fc" id="L537">                mimeType = &quot;application/octet-stream&quot;;</span>
            }

<span class="fc bfc" id="L540" title="All 2 branches covered.">            if (Files.size(staticFilePath) &lt; 100_000) {</span>
<span class="fc" id="L541">                var fileContents = fileReader.readFile(staticFilePath.toString());</span>
<span class="fc" id="L542">                return createOkResponseForStaticFiles(fileContents, mimeType);</span>
            } else {
<span class="fc" id="L544">                return createOkResponseForLargeStaticFiles(mimeType, staticFilePath, requestHeaders);</span>
            }

<span class="fc" id="L547">        } catch (IOException e) {</span>
<span class="fc" id="L548">            logger.logAsyncError(() -&gt; String.format(&quot;Error while reading file: %s. %s&quot;, path, StacktraceUtils.stackTraceToString(e)));</span>
<span class="fc" id="L549">            return Response.buildLeanResponse(CODE_400_BAD_REQUEST);</span>
        }
    }

    /**
     * All static responses will get a cache time of STATIC_FILE_CACHE_TIME seconds
     */
    private IResponse createOkResponseForStaticFiles(byte[] fileContents, String mimeType) {
<span class="fc" id="L557">        var headers = Map.of(</span>
                &quot;cache-control&quot;, &quot;max-age=&quot; + constants.staticFileCacheTime,
                &quot;content-type&quot;, mimeType);

<span class="fc" id="L561">        return Response.buildResponse(</span>
                CODE_200_OK,
                headers,
                fileContents);
    }

    /**
     * All static responses will get a cache time of STATIC_FILE_CACHE_TIME seconds
     */
    private IResponse createOkResponseForLargeStaticFiles(String mimeType, Path filePath, Headers requestHeaders) throws IOException {
<span class="fc" id="L571">        var headers = Map.of(</span>
                &quot;cache-control&quot;, &quot;max-age=&quot; + constants.staticFileCacheTime,
                &quot;content-type&quot;, mimeType,
                &quot;Accept-Ranges&quot;, &quot;bytes&quot;
                );

<span class="fc" id="L577">        return Response.buildLargeFileResponse(</span>
                headers,
<span class="fc" id="L579">                filePath.toString(),</span>
                requestHeaders
                );
    }


    /**
     * These are the default starting values for mappings
     * between file suffixes and appropriate mime types
     */
    private void addDefaultValuesForMimeMap() {
<span class="fc" id="L590">        fileSuffixToMime.put(&quot;css&quot;, &quot;text/css&quot;);</span>
<span class="fc" id="L591">        fileSuffixToMime.put(&quot;js&quot;, &quot;application/javascript&quot;);</span>
<span class="fc" id="L592">        fileSuffixToMime.put(&quot;webp&quot;, &quot;image/webp&quot;);</span>
<span class="fc" id="L593">        fileSuffixToMime.put(&quot;jpg&quot;, &quot;image/jpeg&quot;);</span>
<span class="fc" id="L594">        fileSuffixToMime.put(&quot;jpeg&quot;, &quot;image/jpeg&quot;);</span>
<span class="fc" id="L595">        fileSuffixToMime.put(&quot;htm&quot;, &quot;text/html&quot;);</span>
<span class="fc" id="L596">        fileSuffixToMime.put(&quot;html&quot;, &quot;text/html&quot;);</span>
<span class="fc" id="L597">    }</span>


    /**
     * let's see if we can match the registered paths against a **portion** of the startline
     */
    ThrowingFunction&lt;IRequest, IResponse&gt; findHandlerByPartialMatch(RequestLine sl) {
<span class="fc" id="L604">        String requestedPath = sl.getPathDetails().getIsolatedPath();</span>
<span class="fc" id="L605">        var methodPathFunctionEntry = registeredPartialPaths.entrySet().stream()</span>
<span class="fc bfc" id="L606" title="All 2 branches covered.">                .filter(x -&gt; requestedPath.startsWith(x.getKey().path()) &amp;&amp;</span>
<span class="fc bfc" id="L607" title="All 2 branches covered.">                        x.getKey().method().equals(sl.getMethod()))</span>
<span class="fc" id="L608">                .findFirst().orElse(null);</span>
<span class="fc bfc" id="L609" title="All 2 branches covered.">        if (methodPathFunctionEntry != null) {</span>
<span class="fc" id="L610">            return methodPathFunctionEntry.getValue();</span>
        } else {
<span class="fc" id="L612">            return null;</span>
        }
    }

    /**
     * This constructor is used for the real production system
     */
    WebFramework(Context context) {
<span class="fc" id="L620">        this(context, null, null);</span>
<span class="fc" id="L621">    }</span>

    WebFramework(Context context, ZonedDateTime overrideForDateTime) {
<span class="fc" id="L624">        this(context, overrideForDateTime, null);</span>
<span class="fc" id="L625">    }</span>

    /**
     * This provides the ZonedDateTime as a parameter so we
     * can set the current date (for testing purposes)
     * @param overrideForDateTime for those test cases where we need to control the time
     */
<span class="fc" id="L632">    WebFramework(Context context, ZonedDateTime overrideForDateTime, IFileReader fileReader) {</span>
<span class="fc" id="L633">        this.fs = context.getFullSystem();</span>
<span class="fc bfc" id="L634" title="All 2 branches covered.">        this.theBrig = this.fs != null ? this.fs.getTheBrig() : null;</span>
<span class="fc" id="L635">        this.logger = context.getLogger();</span>
<span class="fc" id="L636">        this.constants = context.getConstants();</span>
<span class="fc" id="L637">        this.overrideForDateTime = overrideForDateTime;</span>
<span class="fc" id="L638">        this.registeredDynamicPaths = new HashMap&lt;&gt;();</span>
<span class="fc" id="L639">        this.registeredPartialPaths = new HashMap&lt;&gt;();</span>
<span class="fc" id="L640">        this.underInvestigation = new UnderInvestigation(constants);</span>
<span class="fc" id="L641">        this.inputStreamUtils = new InputStreamUtils(constants.maxReadLineSizeBytes);</span>
<span class="fc" id="L642">        this.bodyProcessor = new BodyProcessor(context);</span>

        // This random value is purely to help provide correlation between
        // error messages in the UI and error logs.  There are no security concerns.
<span class="fc" id="L646">        this.randomErrorCorrelationId = new Random();</span>
<span class="fc" id="L647">        this.validRequestLine =  new RequestLine(</span>
                RequestLine.Method.NONE,
                PathDetails.empty,
                HttpVersion.NONE,
                &quot;&quot;, logger);
<span class="fc" id="L652">        this.emptyRequestLine = RequestLine.EMPTY;</span>

        // this allows us to inject a IFileReader for deeper testing
<span class="fc bfc" id="L655" title="All 2 branches covered.">        if (fileReader != null) {</span>
<span class="fc" id="L656">            this.fileReader = fileReader;</span>
        } else {
<span class="fc" id="L658">            this.fileReader = new FileReader(</span>
<span class="fc" id="L659">                    LRUCache.getLruCache(constants.maxElementsLruCacheStaticFiles),</span>
                    constants.useCacheForStaticFiles,
                    logger);
        }
<span class="fc" id="L663">        this.fileSuffixToMime = new HashMap&lt;&gt;();</span>
<span class="fc" id="L664">        addDefaultValuesForMimeMap();</span>
<span class="fc" id="L665">        readExtraMimeMappings(constants.extraMimeMappings);</span>
<span class="fc" id="L666">    }</span>

    void readExtraMimeMappings(List&lt;String&gt; input) {
<span class="fc bfc" id="L669" title="All 4 branches covered.">        if (input == null || input.isEmpty()) return;</span>
<span class="fc bfc" id="L670" title="All 2 branches covered.">        if (!(input.size() % 2 == 0)) {</span>
<span class="fc" id="L671">            throw new WebServerException(&quot;input must be even (key + value = 2 items). Your input: &quot; + input);</span>
        }

<span class="fc bfc" id="L674" title="All 2 branches covered.">        for (int i = 0; i &lt; input.size(); i += 2) {</span>
<span class="fc" id="L675">            String fileSuffix = input.get(i);</span>
<span class="fc" id="L676">            String mime = input.get(i+1);</span>
<span class="fc" id="L677">            logger.logTrace(() -&gt; &quot;Adding mime mapping: &quot; + fileSuffix + &quot; -&gt; &quot; + mime);</span>
<span class="fc" id="L678">            fileSuffixToMime.put(fileSuffix, mime);</span>
        }
<span class="fc" id="L680">    }</span>

    /**
     * Add a new handler in the web application for a combination
     * of a {@link RequestLine.Method}, a path, and then provide
     * the code to handle a request.
     * &lt;br&gt;
     * Note that the path text expected is *after* the first forward slash,
     * so for example with {@code http://foo.com/mypath}, provide &quot;mypath&quot; as the path.
     * @throws WebServerException if duplicate paths are registered, or if the path is prefixed with a slash
     */
    public void registerPath(RequestLine.Method method, String pathName, ThrowingFunction&lt;IRequest, IResponse&gt; webHandler) {
<span class="fc bfc" id="L692" title="All 4 branches covered.">        if (pathName.startsWith(&quot;\\&quot;) || pathName.startsWith(&quot;/&quot;)) {</span>
<span class="fc" id="L693">            throw new WebServerException(</span>
<span class="fc" id="L694">                    String.format(&quot;Path should not be prefixed with a slash.  Corrected version: registerPath(%s, \&quot;%s\&quot;, ... )&quot;, method.name(), pathName.substring(1)));</span>
        }

<span class="fc" id="L697">        var result = registeredDynamicPaths.put(new MethodPath(method, pathName), webHandler);</span>
<span class="fc bfc" id="L698" title="All 2 branches covered.">        if (result != null) {</span>
<span class="fc" id="L699">            throw new WebServerException(&quot;Duplicate endpoint registered: &quot; + new MethodPath(method, pathName));</span>
        }
<span class="fc" id="L701">    }</span>

    /**
     * Similar to {@link WebFramework#registerPath(RequestLine.Method, String, ThrowingFunction)} except that the paths
     * registered here may be partially matched.
     * &lt;p&gt;
     *     For example, if you register {@code .well-known/acme-challenge} then it
     *     can match a client request for {@code .well-known/acme-challenge/HGr8U1IeTW4kY_Z6UIyaakzOkyQgPr_7ArlLgtZE8SX}
     * &lt;/p&gt;
     * &lt;p&gt;
     *     Be careful here, be thoughtful - partial paths will match a lot, and may
     *     overlap with other URL's for your app, such as endpoints and static files.
     * &lt;/p&gt;
     * @throws WebServerException if duplicate paths are registered, or if the path is prefixed with a slash
     */
    public void registerPartialPath(RequestLine.Method method, String pathName, ThrowingFunction&lt;IRequest, IResponse&gt; webHandler) {
<span class="fc bfc" id="L717" title="All 4 branches covered.">        if (pathName.startsWith(&quot;\\&quot;) || pathName.startsWith(&quot;/&quot;)) {</span>
<span class="fc" id="L718">            throw new WebServerException(</span>
<span class="fc" id="L719">                    String.format(&quot;Path should not be prefixed with a slash.  Corrected version: registerPartialPath(%s, \&quot;%s\&quot;, ... )&quot;, method.name(), pathName.substring(1)));</span>
        }
<span class="fc" id="L721">        var result = registeredPartialPaths.put(new MethodPath(method, pathName), webHandler);</span>
<span class="fc bfc" id="L722" title="All 2 branches covered.">        if (result != null) {</span>
<span class="fc" id="L723">            throw new WebServerException(&quot;Duplicate partial-path endpoint registered: &quot; + new MethodPath(method, pathName));</span>
        }
<span class="fc" id="L725">    }</span>

    /**
     * Sets a handler to process all requests across the board.
     * &lt;br&gt;
     * &lt;p&gt;
     *     This is an &lt;b&gt;unusual&lt;/b&gt; method.  Setting a handler here allows the user to run code of his
     * choosing before the regular business code is run.  Note that by defining this value, the ordinary
     * call to endpoint.apply(request) will not be run.
     * &lt;/p&gt;
     * &lt;p&gt;Here is an example&lt;/p&gt;
     * &lt;pre&gt;{@code
     *
     *      webFramework.registerPreHandler(preHandlerInputs -&gt; preHandlerCode(preHandlerInputs, auth, context));
     *
     *      ...
     *
     *      private IResponse preHandlerCode(PreHandlerInputs preHandlerInputs, AuthUtils auth, Context context) throws Exception {
     *          int secureServerPort = context.getConstants().secureServerPort;
     *          Request request = preHandlerInputs.clientRequest();
     *          ThrowingFunction&lt;IRequest, IResponse&gt; endpoint = preHandlerInputs.endpoint();
     *          ISocketWrapper sw = preHandlerInputs.sw();
     *
     *          // log all requests
     *          logger.logTrace(() -&gt; String.format(&quot;Request: %s by %s&quot;,
     *              request.requestLine().getRawValue(),
     *              request.remoteRequester())
     *          );
     *
     *          // redirect to https if they are on the plain-text connection and the path is &quot;login&quot;
     *
     *          // get the path from the request line
     *          String path = request.getRequestLine().getPathDetails().getIsolatedPath();
     *
     *          // redirect to https on the configured secure port if they are on the plain-text connection and the path contains &quot;login&quot;
     *          if (path.contains(&quot;login&quot;) &amp;&amp;
     *              sw.getServerType().equals(HttpServerType.PLAIN_TEXT_HTTP)) {
     *              return Response.redirectTo(&quot;https://%s:%d/%s&quot;.formatted(sw.getHostName(), secureServerPort, path));
     *          }
     *
     *          // adjust behavior if non-authenticated and path includes &quot;secure/&quot;
     *          if (path.contains(&quot;secure/&quot;)) {
     *              AuthResult authResult = auth.processAuth(request);
     *              if (authResult.isAuthenticated()) {
     *                  return endpoint.apply(request);
     *              } else {
     *                  return Response.buildLeanResponse(CODE_403_FORBIDDEN);
     *              }
     *          }
     *
     *          // if the path does not include /secure, just move the request along unchanged.
     *          return endpoint.apply(request);
     *      }
     * }&lt;/pre&gt;
     */
        public void registerPreHandler(ThrowingFunction&lt;PreHandlerInputs, IResponse&gt; preHandler) {
<span class="fc" id="L781">        this.preHandler = preHandler;</span>
<span class="fc" id="L782">    }</span>

    /**
     * Sets a handler to be executed after running the ordinary handler, just
     * before sending the response.
     * &lt;p&gt;
     *     This is an &lt;b&gt;unusual&lt;/b&gt; method, so please be aware of its proper use. Its
     *     purpose is to allow the user to inject code to run after ordinary code, across
     *     all requests.
     * &lt;/p&gt;
     * &lt;p&gt;
     *     For example, if the system would have returned a 404 NOT FOUND response,
     *     code can handle that situation in a switch case and adjust the response according
     *     to your programming.
     * &lt;/p&gt;
     * &lt;p&gt;Here is an example&lt;/p&gt;
     * &lt;pre&gt;{@code
     *
     *
     *      webFramework.registerLastMinuteHandler(TheRegister::lastMinuteHandlerCode);
     *
     * ...
     *
     *     private static IResponse lastMinuteHandlerCode(LastMinuteHandlerInputs inputs) {
     *         switch (inputs.response().statusCode()) {
     *             case CODE_404_NOT_FOUND -&gt; {
     *                 return Response.buildResponse(
     *                         CODE_404_NOT_FOUND,
     *                         Map.of(&quot;Content-Type&quot;, &quot;text/html; charset=UTF-8&quot;),
     *                         &quot;&lt;p&gt;No document was found&lt;/p&gt;&quot;));
     *             }
     *             case CODE_500_INTERNAL_SERVER_ERROR -&gt; {
     *                 return Response.buildResponse(
     *                         CODE_500_INTERNAL_SERVER_ERROR,
     *                         Map.of(&quot;Content-Type&quot;, &quot;text/html; charset=UTF-8&quot;),
     *                         &quot;&lt;p&gt;Server error occurred.&lt;/p&gt;&quot; ));
     *             }
     *             default -&gt; {
     *                 return inputs.response();
     *             }
     *         }
     *     }
     * }
     * &lt;/pre&gt;
     * @param lastMinuteHandler a function that will take a request and return a response, exactly like
     *                   we use in the other registration methods for this class.
     */
    public void registerLastMinuteHandler(ThrowingFunction&lt;LastMinuteHandlerInputs, IResponse&gt; lastMinuteHandler) {
<span class="fc" id="L830">        this.lastMinuteHandler = lastMinuteHandler;</span>
<span class="fc" id="L831">    }</span>

    /**
     * This allows users to add extra mappings
     * between file suffixes and mime types, in case
     * a user needs one that was not provided.
     * &lt;p&gt;
     *     This is made available through the
     *     web framework.
     * &lt;/p&gt;
     * &lt;p&gt;
     *     Example:
     * &lt;/p&gt;
     * &lt;pre&gt;
     * {@code webFramework.addMimeForSuffix().put(&quot;foo&quot;,&quot;text/foo&quot;)}
     * &lt;/pre&gt;
     */
    public void addMimeForSuffix(String suffix, String mimeType) {
<span class="fc" id="L849">        fileSuffixToMime.put(suffix, mimeType);</span>
<span class="fc" id="L850">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.12.202403310830</span></div></body></html>